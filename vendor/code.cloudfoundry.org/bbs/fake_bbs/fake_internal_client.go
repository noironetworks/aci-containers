// Code generated by counterfeiter. DO NOT EDIT.
package fake_bbs

import (
	"sync"
	"time"

	"code.cloudfoundry.org/bbs"
	"code.cloudfoundry.org/bbs/events"
	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/lager"
)

type FakeInternalClient struct {
	ActualLRPGroupByProcessGuidAndIndexStub        func(lager.Logger, string, int) (*models.ActualLRPGroup, error)
	actualLRPGroupByProcessGuidAndIndexMutex       sync.RWMutex
	actualLRPGroupByProcessGuidAndIndexArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 int
	}
	actualLRPGroupByProcessGuidAndIndexReturns struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupByProcessGuidAndIndexReturnsOnCall map[int]struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupsStub        func(lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsMutex       sync.RWMutex
	actualLRPGroupsArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}
	actualLRPGroupsReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupsByProcessGuidStub        func(lager.Logger, string) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsByProcessGuidMutex       sync.RWMutex
	actualLRPGroupsByProcessGuidArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	actualLRPGroupsByProcessGuidReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupsByProcessGuidReturnsOnCall map[int]struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPsStub        func(lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRP, error)
	actualLRPsMutex       sync.RWMutex
	actualLRPsArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}
	actualLRPsReturns struct {
		result1 []*models.ActualLRP
		result2 error
	}
	actualLRPsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRP
		result2 error
	}
	CancelTaskStub        func(lager.Logger, string) error
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	cancelTaskReturns struct {
		result1 error
	}
	cancelTaskReturnsOnCall map[int]struct {
		result1 error
	}
	CellsStub        func(lager.Logger) ([]*models.CellPresence, error)
	cellsMutex       sync.RWMutex
	cellsArgsForCall []struct {
		arg1 lager.Logger
	}
	cellsReturns struct {
		result1 []*models.CellPresence
		result2 error
	}
	cellsReturnsOnCall map[int]struct {
		result1 []*models.CellPresence
		result2 error
	}
	ClaimActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 error
	}
	claimActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	CompleteTaskStub        func(lager.Logger, string, string, bool, string, string) error
	completeTaskMutex       sync.RWMutex
	completeTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 bool
		arg5 string
		arg6 string
	}
	completeTaskReturns struct {
		result1 error
	}
	completeTaskReturnsOnCall map[int]struct {
		result1 error
	}
	CrashActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) error
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 string
	}
	crashActualLRPReturns struct {
		result1 error
	}
	crashActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTaskStub        func(lager.Logger, string) error
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	deleteTaskReturns struct {
		result1 error
	}
	deleteTaskReturnsOnCall map[int]struct {
		result1 error
	}
	DesireLRPStub        func(lager.Logger, *models.DesiredLRP) error
	desireLRPMutex       sync.RWMutex
	desireLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.DesiredLRP
	}
	desireLRPReturns struct {
		result1 error
	}
	desireLRPReturnsOnCall map[int]struct {
		result1 error
	}
	DesireTaskStub        func(lager.Logger, string, string, *models.TaskDefinition) error
	desireTaskMutex       sync.RWMutex
	desireTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 *models.TaskDefinition
	}
	desireTaskReturns struct {
		result1 error
	}
	desireTaskReturnsOnCall map[int]struct {
		result1 error
	}
	DesiredLRPByProcessGuidStub        func(lager.Logger, string) (*models.DesiredLRP, error)
	desiredLRPByProcessGuidMutex       sync.RWMutex
	desiredLRPByProcessGuidArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	desiredLRPByProcessGuidReturns struct {
		result1 *models.DesiredLRP
		result2 error
	}
	desiredLRPByProcessGuidReturnsOnCall map[int]struct {
		result1 *models.DesiredLRP
		result2 error
	}
	DesiredLRPSchedulingInfosStub        func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)
	desiredLRPSchedulingInfosMutex       sync.RWMutex
	desiredLRPSchedulingInfosArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}
	desiredLRPSchedulingInfosReturns struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	desiredLRPSchedulingInfosReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	DesiredLRPsStub        func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)
	desiredLRPsMutex       sync.RWMutex
	desiredLRPsArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}
	desiredLRPsReturns struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	desiredLRPsReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	DomainsStub        func(lager.Logger) ([]string, error)
	domainsMutex       sync.RWMutex
	domainsArgsForCall []struct {
		arg1 lager.Logger
	}
	domainsReturns struct {
		result1 []string
		result2 error
	}
	domainsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	EvacuateClaimedActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)
	evacuateClaimedActualLRPMutex       sync.RWMutex
	evacuateClaimedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	evacuateClaimedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateClaimedActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EvacuateCrashedActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) (bool, error)
	evacuateCrashedActualLRPMutex       sync.RWMutex
	evacuateCrashedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 string
	}
	evacuateCrashedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateCrashedActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EvacuateRunningActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) (bool, error)
	evacuateRunningActualLRPMutex       sync.RWMutex
	evacuateRunningActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
	}
	evacuateRunningActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateRunningActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EvacuateStoppedActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)
	evacuateStoppedActualLRPMutex       sync.RWMutex
	evacuateStoppedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	evacuateStoppedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateStoppedActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FailActualLRPStub        func(lager.Logger, *models.ActualLRPKey, string) error
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 string
	}
	failActualLRPReturns struct {
		result1 error
	}
	failActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	FailTaskStub        func(lager.Logger, string, string) error
	failTaskMutex       sync.RWMutex
	failTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	failTaskReturns struct {
		result1 error
	}
	failTaskReturnsOnCall map[int]struct {
		result1 error
	}
	PingStub        func(lager.Logger) bool
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		arg1 lager.Logger
	}
	pingReturns struct {
		result1 bool
	}
	pingReturnsOnCall map[int]struct {
		result1 bool
	}
	RejectTaskStub        func(lager.Logger, string, string) error
	rejectTaskMutex       sync.RWMutex
	rejectTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	rejectTaskReturns struct {
		result1 error
	}
	rejectTaskReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	removeActualLRPReturns struct {
		result1 error
	}
	removeActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveDesiredLRPStub        func(lager.Logger, string) error
	removeDesiredLRPMutex       sync.RWMutex
	removeDesiredLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	removeDesiredLRPReturns struct {
		result1 error
	}
	removeDesiredLRPReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveEvacuatingActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error
	removeEvacuatingActualLRPMutex       sync.RWMutex
	removeEvacuatingActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	removeEvacuatingActualLRPReturns struct {
		result1 error
	}
	removeEvacuatingActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	ResolvingTaskStub        func(lager.Logger, string) error
	resolvingTaskMutex       sync.RWMutex
	resolvingTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	resolvingTaskReturns struct {
		result1 error
	}
	resolvingTaskReturnsOnCall map[int]struct {
		result1 error
	}
	RetireActualLRPStub        func(lager.Logger, *models.ActualLRPKey) error
	retireActualLRPMutex       sync.RWMutex
	retireActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
	}
	retireActualLRPReturns struct {
		result1 error
	}
	retireActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	StartActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) error
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
	}
	startActualLRPReturns struct {
		result1 error
	}
	startActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	StartTaskStub        func(lager.Logger, string, string) (bool, error)
	startTaskMutex       sync.RWMutex
	startTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	startTaskReturns struct {
		result1 bool
		result2 error
	}
	startTaskReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	SubscribeToEventsStub        func(lager.Logger) (events.EventSource, error)
	subscribeToEventsMutex       sync.RWMutex
	subscribeToEventsArgsForCall []struct {
		arg1 lager.Logger
	}
	subscribeToEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToEventsReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToEventsByCellIDStub        func(lager.Logger, string) (events.EventSource, error)
	subscribeToEventsByCellIDMutex       sync.RWMutex
	subscribeToEventsByCellIDArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	subscribeToEventsByCellIDReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToEventsByCellIDReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToInstanceEventsStub        func(lager.Logger) (events.EventSource, error)
	subscribeToInstanceEventsMutex       sync.RWMutex
	subscribeToInstanceEventsArgsForCall []struct {
		arg1 lager.Logger
	}
	subscribeToInstanceEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToInstanceEventsReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToInstanceEventsByCellIDStub        func(lager.Logger, string) (events.EventSource, error)
	subscribeToInstanceEventsByCellIDMutex       sync.RWMutex
	subscribeToInstanceEventsByCellIDArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	subscribeToInstanceEventsByCellIDReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToInstanceEventsByCellIDReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToTaskEventsStub        func(lager.Logger) (events.EventSource, error)
	subscribeToTaskEventsMutex       sync.RWMutex
	subscribeToTaskEventsArgsForCall []struct {
		arg1 lager.Logger
	}
	subscribeToTaskEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToTaskEventsReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	TaskByGuidStub        func(lager.Logger, string) (*models.Task, error)
	taskByGuidMutex       sync.RWMutex
	taskByGuidArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	taskByGuidReturns struct {
		result1 *models.Task
		result2 error
	}
	taskByGuidReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 error
	}
	TasksStub        func(lager.Logger) ([]*models.Task, error)
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct {
		arg1 lager.Logger
	}
	tasksReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksByCellIDStub        func(lager.Logger, string) ([]*models.Task, error)
	tasksByCellIDMutex       sync.RWMutex
	tasksByCellIDArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	tasksByCellIDReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksByCellIDReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksByDomainStub        func(lager.Logger, string) ([]*models.Task, error)
	tasksByDomainMutex       sync.RWMutex
	tasksByDomainArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	tasksByDomainReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksByDomainReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksWithFilterStub        func(lager.Logger, models.TaskFilter) ([]*models.Task, error)
	tasksWithFilterMutex       sync.RWMutex
	tasksWithFilterArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.TaskFilter
	}
	tasksWithFilterReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksWithFilterReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	UpdateDesiredLRPStub        func(lager.Logger, string, *models.DesiredLRPUpdate) error
	updateDesiredLRPMutex       sync.RWMutex
	updateDesiredLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.DesiredLRPUpdate
	}
	updateDesiredLRPReturns struct {
		result1 error
	}
	updateDesiredLRPReturnsOnCall map[int]struct {
		result1 error
	}
	UpsertDomainStub        func(lager.Logger, string, time.Duration) error
	upsertDomainMutex       sync.RWMutex
	upsertDomainArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 time.Duration
	}
	upsertDomainReturns struct {
		result1 error
	}
	upsertDomainReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndex(arg1 lager.Logger, arg2 string, arg3 int) (*models.ActualLRPGroup, error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall[len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)]
	fake.actualLRPGroupByProcessGuidAndIndexArgsForCall = append(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("ActualLRPGroupByProcessGuidAndIndex", []interface{}{arg1, arg2, arg3})
	actualLRPGroupByProcessGuidAndIndexStubCopy := fake.ActualLRPGroupByProcessGuidAndIndexStub
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	if actualLRPGroupByProcessGuidAndIndexStubCopy != nil {
		return actualLRPGroupByProcessGuidAndIndexStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.actualLRPGroupByProcessGuidAndIndexReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexCallCount() int {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexCalls(stub func(lager.Logger, string, int) (*models.ActualLRPGroup, error)) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	fake.ActualLRPGroupByProcessGuidAndIndexStub = stub
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexArgsForCall(i int) (lager.Logger, string, int) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	argsForCall := fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexReturns(result1 *models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	fake.actualLRPGroupByProcessGuidAndIndexReturns = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexReturnsOnCall(i int, result1 *models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	if fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall == nil {
		fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall[i] = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroups(arg1 lager.Logger, arg2 models.ActualLRPFilter) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupsReturnsOnCall[len(fake.actualLRPGroupsArgsForCall)]
	fake.actualLRPGroupsArgsForCall = append(fake.actualLRPGroupsArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("ActualLRPGroups", []interface{}{arg1, arg2})
	actualLRPGroupsStubCopy := fake.ActualLRPGroupsStub
	fake.actualLRPGroupsMutex.Unlock()
	if actualLRPGroupsStubCopy != nil {
		return actualLRPGroupsStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.actualLRPGroupsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) ActualLRPGroupsCallCount() int {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return len(fake.actualLRPGroupsArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupsCalls(stub func(lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRPGroup, error)) {
	fake.actualLRPGroupsMutex.Lock()
	defer fake.actualLRPGroupsMutex.Unlock()
	fake.ActualLRPGroupsStub = stub
}

func (fake *FakeInternalClient) ActualLRPGroupsArgsForCall(i int) (lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	argsForCall := fake.actualLRPGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) ActualLRPGroupsReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsMutex.Lock()
	defer fake.actualLRPGroupsMutex.Unlock()
	fake.ActualLRPGroupsStub = nil
	fake.actualLRPGroupsReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupsReturnsOnCall(i int, result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsMutex.Lock()
	defer fake.actualLRPGroupsMutex.Unlock()
	fake.ActualLRPGroupsStub = nil
	if fake.actualLRPGroupsReturnsOnCall == nil {
		fake.actualLRPGroupsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuid(arg1 lager.Logger, arg2 string) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupsByProcessGuidReturnsOnCall[len(fake.actualLRPGroupsByProcessGuidArgsForCall)]
	fake.actualLRPGroupsByProcessGuidArgsForCall = append(fake.actualLRPGroupsByProcessGuidArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ActualLRPGroupsByProcessGuid", []interface{}{arg1, arg2})
	actualLRPGroupsByProcessGuidStubCopy := fake.ActualLRPGroupsByProcessGuidStub
	fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	if actualLRPGroupsByProcessGuidStubCopy != nil {
		return actualLRPGroupsByProcessGuidStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.actualLRPGroupsByProcessGuidReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidCallCount() int {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return len(fake.actualLRPGroupsByProcessGuidArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidCalls(stub func(lager.Logger, string) ([]*models.ActualLRPGroup, error)) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	defer fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	fake.ActualLRPGroupsByProcessGuidStub = stub
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	argsForCall := fake.actualLRPGroupsByProcessGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	defer fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	fake.ActualLRPGroupsByProcessGuidStub = nil
	fake.actualLRPGroupsByProcessGuidReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidReturnsOnCall(i int, result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	defer fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	fake.ActualLRPGroupsByProcessGuidStub = nil
	if fake.actualLRPGroupsByProcessGuidReturnsOnCall == nil {
		fake.actualLRPGroupsByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupsByProcessGuidReturnsOnCall[i] = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPs(arg1 lager.Logger, arg2 models.ActualLRPFilter) ([]*models.ActualLRP, error) {
	fake.actualLRPsMutex.Lock()
	ret, specificReturn := fake.actualLRPsReturnsOnCall[len(fake.actualLRPsArgsForCall)]
	fake.actualLRPsArgsForCall = append(fake.actualLRPsArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("ActualLRPs", []interface{}{arg1, arg2})
	actualLRPsStubCopy := fake.ActualLRPsStub
	fake.actualLRPsMutex.Unlock()
	if actualLRPsStubCopy != nil {
		return actualLRPsStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.actualLRPsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) ActualLRPsCallCount() int {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	return len(fake.actualLRPsArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPsCalls(stub func(lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRP, error)) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = stub
}

func (fake *FakeInternalClient) ActualLRPsArgsForCall(i int) (lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	argsForCall := fake.actualLRPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) ActualLRPsReturns(result1 []*models.ActualLRP, result2 error) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = nil
	fake.actualLRPsReturns = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPsReturnsOnCall(i int, result1 []*models.ActualLRP, result2 error) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = nil
	if fake.actualLRPsReturnsOnCall == nil {
		fake.actualLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRP
			result2 error
		})
	}
	fake.actualLRPsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) CancelTask(arg1 lager.Logger, arg2 string) error {
	fake.cancelTaskMutex.Lock()
	ret, specificReturn := fake.cancelTaskReturnsOnCall[len(fake.cancelTaskArgsForCall)]
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CancelTask", []interface{}{arg1, arg2})
	cancelTaskStubCopy := fake.CancelTaskStub
	fake.cancelTaskMutex.Unlock()
	if cancelTaskStubCopy != nil {
		return cancelTaskStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cancelTaskReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeInternalClient) CancelTaskCalls(stub func(lager.Logger, string) error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = stub
}

func (fake *FakeInternalClient) CancelTaskArgsForCall(i int) (lager.Logger, string) {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	argsForCall := fake.cancelTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) CancelTaskReturns(result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CancelTaskReturnsOnCall(i int, result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	if fake.cancelTaskReturnsOnCall == nil {
		fake.cancelTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Cells(arg1 lager.Logger) ([]*models.CellPresence, error) {
	fake.cellsMutex.Lock()
	ret, specificReturn := fake.cellsReturnsOnCall[len(fake.cellsArgsForCall)]
	fake.cellsArgsForCall = append(fake.cellsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("Cells", []interface{}{arg1})
	cellsStubCopy := fake.CellsStub
	fake.cellsMutex.Unlock()
	if cellsStubCopy != nil {
		return cellsStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.cellsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) CellsCallCount() int {
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	return len(fake.cellsArgsForCall)
}

func (fake *FakeInternalClient) CellsCalls(stub func(lager.Logger) ([]*models.CellPresence, error)) {
	fake.cellsMutex.Lock()
	defer fake.cellsMutex.Unlock()
	fake.CellsStub = stub
}

func (fake *FakeInternalClient) CellsArgsForCall(i int) lager.Logger {
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	argsForCall := fake.cellsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInternalClient) CellsReturns(result1 []*models.CellPresence, result2 error) {
	fake.cellsMutex.Lock()
	defer fake.cellsMutex.Unlock()
	fake.CellsStub = nil
	fake.cellsReturns = struct {
		result1 []*models.CellPresence
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) CellsReturnsOnCall(i int, result1 []*models.CellPresence, result2 error) {
	fake.cellsMutex.Lock()
	defer fake.cellsMutex.Unlock()
	fake.CellsStub = nil
	if fake.cellsReturnsOnCall == nil {
		fake.cellsReturnsOnCall = make(map[int]struct {
			result1 []*models.CellPresence
			result2 error
		})
	}
	fake.cellsReturnsOnCall[i] = struct {
		result1 []*models.CellPresence
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ClaimActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) error {
	fake.claimActualLRPMutex.Lock()
	ret, specificReturn := fake.claimActualLRPReturnsOnCall[len(fake.claimActualLRPArgsForCall)]
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("ClaimActualLRP", []interface{}{arg1, arg2, arg3})
	claimActualLRPStubCopy := fake.ClaimActualLRPStub
	fake.claimActualLRPMutex.Unlock()
	if claimActualLRPStubCopy != nil {
		return claimActualLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.claimActualLRPReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeInternalClient) ClaimActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = stub
}

func (fake *FakeInternalClient) ClaimActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	argsForCall := fake.claimActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) ClaimActualLRPReturns(result1 error) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ClaimActualLRPReturnsOnCall(i int, result1 error) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = nil
	if fake.claimActualLRPReturnsOnCall == nil {
		fake.claimActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.claimActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CompleteTask(arg1 lager.Logger, arg2 string, arg3 string, arg4 bool, arg5 string, arg6 string) error {
	fake.completeTaskMutex.Lock()
	ret, specificReturn := fake.completeTaskReturnsOnCall[len(fake.completeTaskArgsForCall)]
	fake.completeTaskArgsForCall = append(fake.completeTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 bool
		arg5 string
		arg6 string
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.recordInvocation("CompleteTask", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	completeTaskStubCopy := fake.CompleteTaskStub
	fake.completeTaskMutex.Unlock()
	if completeTaskStubCopy != nil {
		return completeTaskStubCopy(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.completeTaskReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) CompleteTaskCallCount() int {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return len(fake.completeTaskArgsForCall)
}

func (fake *FakeInternalClient) CompleteTaskCalls(stub func(lager.Logger, string, string, bool, string, string) error) {
	fake.completeTaskMutex.Lock()
	defer fake.completeTaskMutex.Unlock()
	fake.CompleteTaskStub = stub
}

func (fake *FakeInternalClient) CompleteTaskArgsForCall(i int) (lager.Logger, string, string, bool, string, string) {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	argsForCall := fake.completeTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeInternalClient) CompleteTaskReturns(result1 error) {
	fake.completeTaskMutex.Lock()
	defer fake.completeTaskMutex.Unlock()
	fake.CompleteTaskStub = nil
	fake.completeTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CompleteTaskReturnsOnCall(i int, result1 error) {
	fake.completeTaskMutex.Lock()
	defer fake.completeTaskMutex.Unlock()
	fake.CompleteTaskStub = nil
	if fake.completeTaskReturnsOnCall == nil {
		fake.completeTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.completeTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CrashActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey, arg4 string) error {
	fake.crashActualLRPMutex.Lock()
	ret, specificReturn := fake.crashActualLRPReturnsOnCall[len(fake.crashActualLRPArgsForCall)]
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("CrashActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	crashActualLRPStubCopy := fake.CrashActualLRPStub
	fake.crashActualLRPMutex.Unlock()
	if crashActualLRPStubCopy != nil {
		return crashActualLRPStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.crashActualLRPReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeInternalClient) CrashActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) error) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = stub
}

func (fake *FakeInternalClient) CrashActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	argsForCall := fake.crashActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) CrashActualLRPReturns(result1 error) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CrashActualLRPReturnsOnCall(i int, result1 error) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = nil
	if fake.crashActualLRPReturnsOnCall == nil {
		fake.crashActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.crashActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DeleteTask(arg1 lager.Logger, arg2 string) error {
	fake.deleteTaskMutex.Lock()
	ret, specificReturn := fake.deleteTaskReturnsOnCall[len(fake.deleteTaskArgsForCall)]
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("DeleteTask", []interface{}{arg1, arg2})
	deleteTaskStubCopy := fake.DeleteTaskStub
	fake.deleteTaskMutex.Unlock()
	if deleteTaskStubCopy != nil {
		return deleteTaskStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteTaskReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeInternalClient) DeleteTaskCalls(stub func(lager.Logger, string) error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = stub
}

func (fake *FakeInternalClient) DeleteTaskArgsForCall(i int) (lager.Logger, string) {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	argsForCall := fake.deleteTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) DeleteTaskReturns(result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DeleteTaskReturnsOnCall(i int, result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	if fake.deleteTaskReturnsOnCall == nil {
		fake.deleteTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesireLRP(arg1 lager.Logger, arg2 *models.DesiredLRP) error {
	fake.desireLRPMutex.Lock()
	ret, specificReturn := fake.desireLRPReturnsOnCall[len(fake.desireLRPArgsForCall)]
	fake.desireLRPArgsForCall = append(fake.desireLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.DesiredLRP
	}{arg1, arg2})
	fake.recordInvocation("DesireLRP", []interface{}{arg1, arg2})
	desireLRPStubCopy := fake.DesireLRPStub
	fake.desireLRPMutex.Unlock()
	if desireLRPStubCopy != nil {
		return desireLRPStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.desireLRPReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) DesireLRPCallCount() int {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return len(fake.desireLRPArgsForCall)
}

func (fake *FakeInternalClient) DesireLRPCalls(stub func(lager.Logger, *models.DesiredLRP) error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = stub
}

func (fake *FakeInternalClient) DesireLRPArgsForCall(i int) (lager.Logger, *models.DesiredLRP) {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	argsForCall := fake.desireLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) DesireLRPReturns(result1 error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = nil
	fake.desireLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesireLRPReturnsOnCall(i int, result1 error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = nil
	if fake.desireLRPReturnsOnCall == nil {
		fake.desireLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.desireLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesireTask(arg1 lager.Logger, arg2 string, arg3 string, arg4 *models.TaskDefinition) error {
	fake.desireTaskMutex.Lock()
	ret, specificReturn := fake.desireTaskReturnsOnCall[len(fake.desireTaskArgsForCall)]
	fake.desireTaskArgsForCall = append(fake.desireTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 *models.TaskDefinition
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("DesireTask", []interface{}{arg1, arg2, arg3, arg4})
	desireTaskStubCopy := fake.DesireTaskStub
	fake.desireTaskMutex.Unlock()
	if desireTaskStubCopy != nil {
		return desireTaskStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.desireTaskReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) DesireTaskCallCount() int {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return len(fake.desireTaskArgsForCall)
}

func (fake *FakeInternalClient) DesireTaskCalls(stub func(lager.Logger, string, string, *models.TaskDefinition) error) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = stub
}

func (fake *FakeInternalClient) DesireTaskArgsForCall(i int) (lager.Logger, string, string, *models.TaskDefinition) {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	argsForCall := fake.desireTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) DesireTaskReturns(result1 error) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = nil
	fake.desireTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesireTaskReturnsOnCall(i int, result1 error) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = nil
	if fake.desireTaskReturnsOnCall == nil {
		fake.desireTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.desireTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuid(arg1 lager.Logger, arg2 string) (*models.DesiredLRP, error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	ret, specificReturn := fake.desiredLRPByProcessGuidReturnsOnCall[len(fake.desiredLRPByProcessGuidArgsForCall)]
	fake.desiredLRPByProcessGuidArgsForCall = append(fake.desiredLRPByProcessGuidArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("DesiredLRPByProcessGuid", []interface{}{arg1, arg2})
	desiredLRPByProcessGuidStubCopy := fake.DesiredLRPByProcessGuidStub
	fake.desiredLRPByProcessGuidMutex.Unlock()
	if desiredLRPByProcessGuidStubCopy != nil {
		return desiredLRPByProcessGuidStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.desiredLRPByProcessGuidReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidCallCount() int {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return len(fake.desiredLRPByProcessGuidArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidCalls(stub func(lager.Logger, string) (*models.DesiredLRP, error)) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = stub
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	argsForCall := fake.desiredLRPByProcessGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidReturns(result1 *models.DesiredLRP, result2 error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = nil
	fake.desiredLRPByProcessGuidReturns = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidReturnsOnCall(i int, result1 *models.DesiredLRP, result2 error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = nil
	if fake.desiredLRPByProcessGuidReturnsOnCall == nil {
		fake.desiredLRPByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 *models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPByProcessGuidReturnsOnCall[i] = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfos(arg1 lager.Logger, arg2 models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	ret, specificReturn := fake.desiredLRPSchedulingInfosReturnsOnCall[len(fake.desiredLRPSchedulingInfosArgsForCall)]
	fake.desiredLRPSchedulingInfosArgsForCall = append(fake.desiredLRPSchedulingInfosArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("DesiredLRPSchedulingInfos", []interface{}{arg1, arg2})
	desiredLRPSchedulingInfosStubCopy := fake.DesiredLRPSchedulingInfosStub
	fake.desiredLRPSchedulingInfosMutex.Unlock()
	if desiredLRPSchedulingInfosStubCopy != nil {
		return desiredLRPSchedulingInfosStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.desiredLRPSchedulingInfosReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosCallCount() int {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return len(fake.desiredLRPSchedulingInfosArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosCalls(stub func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = stub
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	argsForCall := fake.desiredLRPSchedulingInfosArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosReturns(result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = nil
	fake.desiredLRPSchedulingInfosReturns = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosReturnsOnCall(i int, result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = nil
	if fake.desiredLRPSchedulingInfosReturnsOnCall == nil {
		fake.desiredLRPSchedulingInfosReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRPSchedulingInfo
			result2 error
		})
	}
	fake.desiredLRPSchedulingInfosReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPs(arg1 lager.Logger, arg2 models.DesiredLRPFilter) ([]*models.DesiredLRP, error) {
	fake.desiredLRPsMutex.Lock()
	ret, specificReturn := fake.desiredLRPsReturnsOnCall[len(fake.desiredLRPsArgsForCall)]
	fake.desiredLRPsArgsForCall = append(fake.desiredLRPsArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("DesiredLRPs", []interface{}{arg1, arg2})
	desiredLRPsStubCopy := fake.DesiredLRPsStub
	fake.desiredLRPsMutex.Unlock()
	if desiredLRPsStubCopy != nil {
		return desiredLRPsStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.desiredLRPsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) DesiredLRPsCallCount() int {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return len(fake.desiredLRPsArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPsCalls(stub func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = stub
}

func (fake *FakeInternalClient) DesiredLRPsArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	argsForCall := fake.desiredLRPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) DesiredLRPsReturns(result1 []*models.DesiredLRP, result2 error) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = nil
	fake.desiredLRPsReturns = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPsReturnsOnCall(i int, result1 []*models.DesiredLRP, result2 error) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = nil
	if fake.desiredLRPsReturnsOnCall == nil {
		fake.desiredLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPsReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) Domains(arg1 lager.Logger) ([]string, error) {
	fake.domainsMutex.Lock()
	ret, specificReturn := fake.domainsReturnsOnCall[len(fake.domainsArgsForCall)]
	fake.domainsArgsForCall = append(fake.domainsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("Domains", []interface{}{arg1})
	domainsStubCopy := fake.DomainsStub
	fake.domainsMutex.Unlock()
	if domainsStubCopy != nil {
		return domainsStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.domainsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) DomainsCallCount() int {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	return len(fake.domainsArgsForCall)
}

func (fake *FakeInternalClient) DomainsCalls(stub func(lager.Logger) ([]string, error)) {
	fake.domainsMutex.Lock()
	defer fake.domainsMutex.Unlock()
	fake.DomainsStub = stub
}

func (fake *FakeInternalClient) DomainsArgsForCall(i int) lager.Logger {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	argsForCall := fake.domainsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInternalClient) DomainsReturns(result1 []string, result2 error) {
	fake.domainsMutex.Lock()
	defer fake.domainsMutex.Unlock()
	fake.DomainsStub = nil
	fake.domainsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DomainsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.domainsMutex.Lock()
	defer fake.domainsMutex.Unlock()
	fake.DomainsStub = nil
	if fake.domainsReturnsOnCall == nil {
		fake.domainsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.domainsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) (bool, error) {
	fake.evacuateClaimedActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateClaimedActualLRPReturnsOnCall[len(fake.evacuateClaimedActualLRPArgsForCall)]
	fake.evacuateClaimedActualLRPArgsForCall = append(fake.evacuateClaimedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("EvacuateClaimedActualLRP", []interface{}{arg1, arg2, arg3})
	evacuateClaimedActualLRPStubCopy := fake.EvacuateClaimedActualLRPStub
	fake.evacuateClaimedActualLRPMutex.Unlock()
	if evacuateClaimedActualLRPStubCopy != nil {
		return evacuateClaimedActualLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.evacuateClaimedActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPCallCount() int {
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	return len(fake.evacuateClaimedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)) {
	fake.evacuateClaimedActualLRPMutex.Lock()
	defer fake.evacuateClaimedActualLRPMutex.Unlock()
	fake.EvacuateClaimedActualLRPStub = stub
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	argsForCall := fake.evacuateClaimedActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPReturns(result1 bool, result2 error) {
	fake.evacuateClaimedActualLRPMutex.Lock()
	defer fake.evacuateClaimedActualLRPMutex.Unlock()
	fake.EvacuateClaimedActualLRPStub = nil
	fake.evacuateClaimedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.evacuateClaimedActualLRPMutex.Lock()
	defer fake.evacuateClaimedActualLRPMutex.Unlock()
	fake.EvacuateClaimedActualLRPStub = nil
	if fake.evacuateClaimedActualLRPReturnsOnCall == nil {
		fake.evacuateClaimedActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateClaimedActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey, arg4 string) (bool, error) {
	fake.evacuateCrashedActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateCrashedActualLRPReturnsOnCall[len(fake.evacuateCrashedActualLRPArgsForCall)]
	fake.evacuateCrashedActualLRPArgsForCall = append(fake.evacuateCrashedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("EvacuateCrashedActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	evacuateCrashedActualLRPStubCopy := fake.EvacuateCrashedActualLRPStub
	fake.evacuateCrashedActualLRPMutex.Unlock()
	if evacuateCrashedActualLRPStubCopy != nil {
		return evacuateCrashedActualLRPStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.evacuateCrashedActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPCallCount() int {
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	return len(fake.evacuateCrashedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) (bool, error)) {
	fake.evacuateCrashedActualLRPMutex.Lock()
	defer fake.evacuateCrashedActualLRPMutex.Unlock()
	fake.EvacuateCrashedActualLRPStub = stub
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	argsForCall := fake.evacuateCrashedActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPReturns(result1 bool, result2 error) {
	fake.evacuateCrashedActualLRPMutex.Lock()
	defer fake.evacuateCrashedActualLRPMutex.Unlock()
	fake.EvacuateCrashedActualLRPStub = nil
	fake.evacuateCrashedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.evacuateCrashedActualLRPMutex.Lock()
	defer fake.evacuateCrashedActualLRPMutex.Unlock()
	fake.EvacuateCrashedActualLRPStub = nil
	if fake.evacuateCrashedActualLRPReturnsOnCall == nil {
		fake.evacuateCrashedActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateCrashedActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateRunningActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey, arg4 *models.ActualLRPNetInfo) (bool, error) {
	fake.evacuateRunningActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateRunningActualLRPReturnsOnCall[len(fake.evacuateRunningActualLRPArgsForCall)]
	fake.evacuateRunningActualLRPArgsForCall = append(fake.evacuateRunningActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("EvacuateRunningActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	evacuateRunningActualLRPStubCopy := fake.EvacuateRunningActualLRPStub
	fake.evacuateRunningActualLRPMutex.Unlock()
	if evacuateRunningActualLRPStubCopy != nil {
		return evacuateRunningActualLRPStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.evacuateRunningActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPCallCount() int {
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	return len(fake.evacuateRunningActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) (bool, error)) {
	fake.evacuateRunningActualLRPMutex.Lock()
	defer fake.evacuateRunningActualLRPMutex.Unlock()
	fake.EvacuateRunningActualLRPStub = stub
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	argsForCall := fake.evacuateRunningActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPReturns(result1 bool, result2 error) {
	fake.evacuateRunningActualLRPMutex.Lock()
	defer fake.evacuateRunningActualLRPMutex.Unlock()
	fake.EvacuateRunningActualLRPStub = nil
	fake.evacuateRunningActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.evacuateRunningActualLRPMutex.Lock()
	defer fake.evacuateRunningActualLRPMutex.Unlock()
	fake.EvacuateRunningActualLRPStub = nil
	if fake.evacuateRunningActualLRPReturnsOnCall == nil {
		fake.evacuateRunningActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateRunningActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) (bool, error) {
	fake.evacuateStoppedActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateStoppedActualLRPReturnsOnCall[len(fake.evacuateStoppedActualLRPArgsForCall)]
	fake.evacuateStoppedActualLRPArgsForCall = append(fake.evacuateStoppedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("EvacuateStoppedActualLRP", []interface{}{arg1, arg2, arg3})
	evacuateStoppedActualLRPStubCopy := fake.EvacuateStoppedActualLRPStub
	fake.evacuateStoppedActualLRPMutex.Unlock()
	if evacuateStoppedActualLRPStubCopy != nil {
		return evacuateStoppedActualLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.evacuateStoppedActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPCallCount() int {
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	return len(fake.evacuateStoppedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)) {
	fake.evacuateStoppedActualLRPMutex.Lock()
	defer fake.evacuateStoppedActualLRPMutex.Unlock()
	fake.EvacuateStoppedActualLRPStub = stub
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	argsForCall := fake.evacuateStoppedActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPReturns(result1 bool, result2 error) {
	fake.evacuateStoppedActualLRPMutex.Lock()
	defer fake.evacuateStoppedActualLRPMutex.Unlock()
	fake.EvacuateStoppedActualLRPStub = nil
	fake.evacuateStoppedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.evacuateStoppedActualLRPMutex.Lock()
	defer fake.evacuateStoppedActualLRPMutex.Unlock()
	fake.EvacuateStoppedActualLRPStub = nil
	if fake.evacuateStoppedActualLRPReturnsOnCall == nil {
		fake.evacuateStoppedActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateStoppedActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) FailActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 string) error {
	fake.failActualLRPMutex.Lock()
	ret, specificReturn := fake.failActualLRPReturnsOnCall[len(fake.failActualLRPArgsForCall)]
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("FailActualLRP", []interface{}{arg1, arg2, arg3})
	failActualLRPStubCopy := fake.FailActualLRPStub
	fake.failActualLRPMutex.Unlock()
	if failActualLRPStubCopy != nil {
		return failActualLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.failActualLRPReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeInternalClient) FailActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey, string) error) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = stub
}

func (fake *FakeInternalClient) FailActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	argsForCall := fake.failActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) FailActualLRPReturns(result1 error) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) FailActualLRPReturnsOnCall(i int, result1 error) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = nil
	if fake.failActualLRPReturnsOnCall == nil {
		fake.failActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) FailTask(arg1 lager.Logger, arg2 string, arg3 string) error {
	fake.failTaskMutex.Lock()
	ret, specificReturn := fake.failTaskReturnsOnCall[len(fake.failTaskArgsForCall)]
	fake.failTaskArgsForCall = append(fake.failTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("FailTask", []interface{}{arg1, arg2, arg3})
	failTaskStubCopy := fake.FailTaskStub
	fake.failTaskMutex.Unlock()
	if failTaskStubCopy != nil {
		return failTaskStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.failTaskReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) FailTaskCallCount() int {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return len(fake.failTaskArgsForCall)
}

func (fake *FakeInternalClient) FailTaskCalls(stub func(lager.Logger, string, string) error) {
	fake.failTaskMutex.Lock()
	defer fake.failTaskMutex.Unlock()
	fake.FailTaskStub = stub
}

func (fake *FakeInternalClient) FailTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	argsForCall := fake.failTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) FailTaskReturns(result1 error) {
	fake.failTaskMutex.Lock()
	defer fake.failTaskMutex.Unlock()
	fake.FailTaskStub = nil
	fake.failTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) FailTaskReturnsOnCall(i int, result1 error) {
	fake.failTaskMutex.Lock()
	defer fake.failTaskMutex.Unlock()
	fake.FailTaskStub = nil
	if fake.failTaskReturnsOnCall == nil {
		fake.failTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Ping(arg1 lager.Logger) bool {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("Ping", []interface{}{arg1})
	pingStubCopy := fake.PingStub
	fake.pingMutex.Unlock()
	if pingStubCopy != nil {
		return pingStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pingReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeInternalClient) PingCalls(stub func(lager.Logger) bool) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *FakeInternalClient) PingArgsForCall(i int) lager.Logger {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	argsForCall := fake.pingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInternalClient) PingReturns(result1 bool) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInternalClient) PingReturnsOnCall(i int, result1 bool) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInternalClient) RejectTask(arg1 lager.Logger, arg2 string, arg3 string) error {
	fake.rejectTaskMutex.Lock()
	ret, specificReturn := fake.rejectTaskReturnsOnCall[len(fake.rejectTaskArgsForCall)]
	fake.rejectTaskArgsForCall = append(fake.rejectTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("RejectTask", []interface{}{arg1, arg2, arg3})
	rejectTaskStubCopy := fake.RejectTaskStub
	fake.rejectTaskMutex.Unlock()
	if rejectTaskStubCopy != nil {
		return rejectTaskStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.rejectTaskReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) RejectTaskCallCount() int {
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	return len(fake.rejectTaskArgsForCall)
}

func (fake *FakeInternalClient) RejectTaskCalls(stub func(lager.Logger, string, string) error) {
	fake.rejectTaskMutex.Lock()
	defer fake.rejectTaskMutex.Unlock()
	fake.RejectTaskStub = stub
}

func (fake *FakeInternalClient) RejectTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	argsForCall := fake.rejectTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) RejectTaskReturns(result1 error) {
	fake.rejectTaskMutex.Lock()
	defer fake.rejectTaskMutex.Unlock()
	fake.RejectTaskStub = nil
	fake.rejectTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RejectTaskReturnsOnCall(i int, result1 error) {
	fake.rejectTaskMutex.Lock()
	defer fake.rejectTaskMutex.Unlock()
	fake.RejectTaskStub = nil
	if fake.rejectTaskReturnsOnCall == nil {
		fake.rejectTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rejectTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) error {
	fake.removeActualLRPMutex.Lock()
	ret, specificReturn := fake.removeActualLRPReturnsOnCall[len(fake.removeActualLRPArgsForCall)]
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveActualLRP", []interface{}{arg1, arg2, arg3})
	removeActualLRPStubCopy := fake.RemoveActualLRPStub
	fake.removeActualLRPMutex.Unlock()
	if removeActualLRPStubCopy != nil {
		return removeActualLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeActualLRPReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = stub
}

func (fake *FakeInternalClient) RemoveActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	argsForCall := fake.removeActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) RemoveActualLRPReturns(result1 error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveActualLRPReturnsOnCall(i int, result1 error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = nil
	if fake.removeActualLRPReturnsOnCall == nil {
		fake.removeActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveDesiredLRP(arg1 lager.Logger, arg2 string) error {
	fake.removeDesiredLRPMutex.Lock()
	ret, specificReturn := fake.removeDesiredLRPReturnsOnCall[len(fake.removeDesiredLRPArgsForCall)]
	fake.removeDesiredLRPArgsForCall = append(fake.removeDesiredLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RemoveDesiredLRP", []interface{}{arg1, arg2})
	removeDesiredLRPStubCopy := fake.RemoveDesiredLRPStub
	fake.removeDesiredLRPMutex.Unlock()
	if removeDesiredLRPStubCopy != nil {
		return removeDesiredLRPStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeDesiredLRPReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) RemoveDesiredLRPCallCount() int {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return len(fake.removeDesiredLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveDesiredLRPCalls(stub func(lager.Logger, string) error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = stub
}

func (fake *FakeInternalClient) RemoveDesiredLRPArgsForCall(i int) (lager.Logger, string) {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	argsForCall := fake.removeDesiredLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) RemoveDesiredLRPReturns(result1 error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = nil
	fake.removeDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveDesiredLRPReturnsOnCall(i int, result1 error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = nil
	if fake.removeDesiredLRPReturnsOnCall == nil {
		fake.removeDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeDesiredLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) error {
	fake.removeEvacuatingActualLRPMutex.Lock()
	ret, specificReturn := fake.removeEvacuatingActualLRPReturnsOnCall[len(fake.removeEvacuatingActualLRPArgsForCall)]
	fake.removeEvacuatingActualLRPArgsForCall = append(fake.removeEvacuatingActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveEvacuatingActualLRP", []interface{}{arg1, arg2, arg3})
	removeEvacuatingActualLRPStubCopy := fake.RemoveEvacuatingActualLRPStub
	fake.removeEvacuatingActualLRPMutex.Unlock()
	if removeEvacuatingActualLRPStubCopy != nil {
		return removeEvacuatingActualLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeEvacuatingActualLRPReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPCallCount() int {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return len(fake.removeEvacuatingActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error) {
	fake.removeEvacuatingActualLRPMutex.Lock()
	defer fake.removeEvacuatingActualLRPMutex.Unlock()
	fake.RemoveEvacuatingActualLRPStub = stub
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	argsForCall := fake.removeEvacuatingActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPReturns(result1 error) {
	fake.removeEvacuatingActualLRPMutex.Lock()
	defer fake.removeEvacuatingActualLRPMutex.Unlock()
	fake.RemoveEvacuatingActualLRPStub = nil
	fake.removeEvacuatingActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPReturnsOnCall(i int, result1 error) {
	fake.removeEvacuatingActualLRPMutex.Lock()
	defer fake.removeEvacuatingActualLRPMutex.Unlock()
	fake.RemoveEvacuatingActualLRPStub = nil
	if fake.removeEvacuatingActualLRPReturnsOnCall == nil {
		fake.removeEvacuatingActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeEvacuatingActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ResolvingTask(arg1 lager.Logger, arg2 string) error {
	fake.resolvingTaskMutex.Lock()
	ret, specificReturn := fake.resolvingTaskReturnsOnCall[len(fake.resolvingTaskArgsForCall)]
	fake.resolvingTaskArgsForCall = append(fake.resolvingTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ResolvingTask", []interface{}{arg1, arg2})
	resolvingTaskStubCopy := fake.ResolvingTaskStub
	fake.resolvingTaskMutex.Unlock()
	if resolvingTaskStubCopy != nil {
		return resolvingTaskStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resolvingTaskReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) ResolvingTaskCallCount() int {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return len(fake.resolvingTaskArgsForCall)
}

func (fake *FakeInternalClient) ResolvingTaskCalls(stub func(lager.Logger, string) error) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = stub
}

func (fake *FakeInternalClient) ResolvingTaskArgsForCall(i int) (lager.Logger, string) {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	argsForCall := fake.resolvingTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) ResolvingTaskReturns(result1 error) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = nil
	fake.resolvingTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ResolvingTaskReturnsOnCall(i int, result1 error) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = nil
	if fake.resolvingTaskReturnsOnCall == nil {
		fake.resolvingTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resolvingTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RetireActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey) error {
	fake.retireActualLRPMutex.Lock()
	ret, specificReturn := fake.retireActualLRPReturnsOnCall[len(fake.retireActualLRPArgsForCall)]
	fake.retireActualLRPArgsForCall = append(fake.retireActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
	}{arg1, arg2})
	fake.recordInvocation("RetireActualLRP", []interface{}{arg1, arg2})
	retireActualLRPStubCopy := fake.RetireActualLRPStub
	fake.retireActualLRPMutex.Unlock()
	if retireActualLRPStubCopy != nil {
		return retireActualLRPStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.retireActualLRPReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) RetireActualLRPCallCount() int {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	return len(fake.retireActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RetireActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey) error) {
	fake.retireActualLRPMutex.Lock()
	defer fake.retireActualLRPMutex.Unlock()
	fake.RetireActualLRPStub = stub
}

func (fake *FakeInternalClient) RetireActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	argsForCall := fake.retireActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) RetireActualLRPReturns(result1 error) {
	fake.retireActualLRPMutex.Lock()
	defer fake.retireActualLRPMutex.Unlock()
	fake.RetireActualLRPStub = nil
	fake.retireActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RetireActualLRPReturnsOnCall(i int, result1 error) {
	fake.retireActualLRPMutex.Lock()
	defer fake.retireActualLRPMutex.Unlock()
	fake.RetireActualLRPStub = nil
	if fake.retireActualLRPReturnsOnCall == nil {
		fake.retireActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.retireActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) StartActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey, arg4 *models.ActualLRPNetInfo) error {
	fake.startActualLRPMutex.Lock()
	ret, specificReturn := fake.startActualLRPReturnsOnCall[len(fake.startActualLRPArgsForCall)]
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("StartActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	startActualLRPStubCopy := fake.StartActualLRPStub
	fake.startActualLRPMutex.Unlock()
	if startActualLRPStubCopy != nil {
		return startActualLRPStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startActualLRPReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeInternalClient) StartActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) error) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = stub
}

func (fake *FakeInternalClient) StartActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	argsForCall := fake.startActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) StartActualLRPReturns(result1 error) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) StartActualLRPReturnsOnCall(i int, result1 error) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = nil
	if fake.startActualLRPReturnsOnCall == nil {
		fake.startActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) StartTask(arg1 lager.Logger, arg2 string, arg3 string) (bool, error) {
	fake.startTaskMutex.Lock()
	ret, specificReturn := fake.startTaskReturnsOnCall[len(fake.startTaskArgsForCall)]
	fake.startTaskArgsForCall = append(fake.startTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("StartTask", []interface{}{arg1, arg2, arg3})
	startTaskStubCopy := fake.StartTaskStub
	fake.startTaskMutex.Unlock()
	if startTaskStubCopy != nil {
		return startTaskStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.startTaskReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) StartTaskCallCount() int {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return len(fake.startTaskArgsForCall)
}

func (fake *FakeInternalClient) StartTaskCalls(stub func(lager.Logger, string, string) (bool, error)) {
	fake.startTaskMutex.Lock()
	defer fake.startTaskMutex.Unlock()
	fake.StartTaskStub = stub
}

func (fake *FakeInternalClient) StartTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	argsForCall := fake.startTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) StartTaskReturns(result1 bool, result2 error) {
	fake.startTaskMutex.Lock()
	defer fake.startTaskMutex.Unlock()
	fake.StartTaskStub = nil
	fake.startTaskReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) StartTaskReturnsOnCall(i int, result1 bool, result2 error) {
	fake.startTaskMutex.Lock()
	defer fake.startTaskMutex.Unlock()
	fake.StartTaskStub = nil
	if fake.startTaskReturnsOnCall == nil {
		fake.startTaskReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.startTaskReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToEvents(arg1 lager.Logger) (events.EventSource, error) {
	fake.subscribeToEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToEventsReturnsOnCall[len(fake.subscribeToEventsArgsForCall)]
	fake.subscribeToEventsArgsForCall = append(fake.subscribeToEventsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("SubscribeToEvents", []interface{}{arg1})
	subscribeToEventsStubCopy := fake.SubscribeToEventsStub
	fake.subscribeToEventsMutex.Unlock()
	if subscribeToEventsStubCopy != nil {
		return subscribeToEventsStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToEventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) SubscribeToEventsCallCount() int {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return len(fake.subscribeToEventsArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToEventsCalls(stub func(lager.Logger) (events.EventSource, error)) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = stub
}

func (fake *FakeInternalClient) SubscribeToEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	argsForCall := fake.subscribeToEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInternalClient) SubscribeToEventsReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = nil
	fake.subscribeToEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToEventsReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = nil
	if fake.subscribeToEventsReturnsOnCall == nil {
		fake.subscribeToEventsReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToEventsReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToEventsByCellID(arg1 lager.Logger, arg2 string) (events.EventSource, error) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	ret, specificReturn := fake.subscribeToEventsByCellIDReturnsOnCall[len(fake.subscribeToEventsByCellIDArgsForCall)]
	fake.subscribeToEventsByCellIDArgsForCall = append(fake.subscribeToEventsByCellIDArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SubscribeToEventsByCellID", []interface{}{arg1, arg2})
	subscribeToEventsByCellIDStubCopy := fake.SubscribeToEventsByCellIDStub
	fake.subscribeToEventsByCellIDMutex.Unlock()
	if subscribeToEventsByCellIDStubCopy != nil {
		return subscribeToEventsByCellIDStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToEventsByCellIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDCallCount() int {
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	return len(fake.subscribeToEventsByCellIDArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDCalls(stub func(lager.Logger, string) (events.EventSource, error)) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	defer fake.subscribeToEventsByCellIDMutex.Unlock()
	fake.SubscribeToEventsByCellIDStub = stub
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDArgsForCall(i int) (lager.Logger, string) {
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	argsForCall := fake.subscribeToEventsByCellIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	defer fake.subscribeToEventsByCellIDMutex.Unlock()
	fake.SubscribeToEventsByCellIDStub = nil
	fake.subscribeToEventsByCellIDReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	defer fake.subscribeToEventsByCellIDMutex.Unlock()
	fake.SubscribeToEventsByCellIDStub = nil
	if fake.subscribeToEventsByCellIDReturnsOnCall == nil {
		fake.subscribeToEventsByCellIDReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToEventsByCellIDReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToInstanceEvents(arg1 lager.Logger) (events.EventSource, error) {
	fake.subscribeToInstanceEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToInstanceEventsReturnsOnCall[len(fake.subscribeToInstanceEventsArgsForCall)]
	fake.subscribeToInstanceEventsArgsForCall = append(fake.subscribeToInstanceEventsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("SubscribeToInstanceEvents", []interface{}{arg1})
	subscribeToInstanceEventsStubCopy := fake.SubscribeToInstanceEventsStub
	fake.subscribeToInstanceEventsMutex.Unlock()
	if subscribeToInstanceEventsStubCopy != nil {
		return subscribeToInstanceEventsStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToInstanceEventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsCallCount() int {
	fake.subscribeToInstanceEventsMutex.RLock()
	defer fake.subscribeToInstanceEventsMutex.RUnlock()
	return len(fake.subscribeToInstanceEventsArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsCalls(stub func(lager.Logger) (events.EventSource, error)) {
	fake.subscribeToInstanceEventsMutex.Lock()
	defer fake.subscribeToInstanceEventsMutex.Unlock()
	fake.SubscribeToInstanceEventsStub = stub
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToInstanceEventsMutex.RLock()
	defer fake.subscribeToInstanceEventsMutex.RUnlock()
	argsForCall := fake.subscribeToInstanceEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsMutex.Lock()
	defer fake.subscribeToInstanceEventsMutex.Unlock()
	fake.SubscribeToInstanceEventsStub = nil
	fake.subscribeToInstanceEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsMutex.Lock()
	defer fake.subscribeToInstanceEventsMutex.Unlock()
	fake.SubscribeToInstanceEventsStub = nil
	if fake.subscribeToInstanceEventsReturnsOnCall == nil {
		fake.subscribeToInstanceEventsReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToInstanceEventsReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellID(arg1 lager.Logger, arg2 string) (events.EventSource, error) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	ret, specificReturn := fake.subscribeToInstanceEventsByCellIDReturnsOnCall[len(fake.subscribeToInstanceEventsByCellIDArgsForCall)]
	fake.subscribeToInstanceEventsByCellIDArgsForCall = append(fake.subscribeToInstanceEventsByCellIDArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SubscribeToInstanceEventsByCellID", []interface{}{arg1, arg2})
	subscribeToInstanceEventsByCellIDStubCopy := fake.SubscribeToInstanceEventsByCellIDStub
	fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	if subscribeToInstanceEventsByCellIDStubCopy != nil {
		return subscribeToInstanceEventsByCellIDStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToInstanceEventsByCellIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellIDCallCount() int {
	fake.subscribeToInstanceEventsByCellIDMutex.RLock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.RUnlock()
	return len(fake.subscribeToInstanceEventsByCellIDArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellIDCalls(stub func(lager.Logger, string) (events.EventSource, error)) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	fake.SubscribeToInstanceEventsByCellIDStub = stub
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellIDArgsForCall(i int) (lager.Logger, string) {
	fake.subscribeToInstanceEventsByCellIDMutex.RLock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.RUnlock()
	argsForCall := fake.subscribeToInstanceEventsByCellIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellIDReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	fake.SubscribeToInstanceEventsByCellIDStub = nil
	fake.subscribeToInstanceEventsByCellIDReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellIDReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	fake.SubscribeToInstanceEventsByCellIDStub = nil
	if fake.subscribeToInstanceEventsByCellIDReturnsOnCall == nil {
		fake.subscribeToInstanceEventsByCellIDReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToInstanceEventsByCellIDReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToTaskEvents(arg1 lager.Logger) (events.EventSource, error) {
	fake.subscribeToTaskEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToTaskEventsReturnsOnCall[len(fake.subscribeToTaskEventsArgsForCall)]
	fake.subscribeToTaskEventsArgsForCall = append(fake.subscribeToTaskEventsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("SubscribeToTaskEvents", []interface{}{arg1})
	subscribeToTaskEventsStubCopy := fake.SubscribeToTaskEventsStub
	fake.subscribeToTaskEventsMutex.Unlock()
	if subscribeToTaskEventsStubCopy != nil {
		return subscribeToTaskEventsStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToTaskEventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) SubscribeToTaskEventsCallCount() int {
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	return len(fake.subscribeToTaskEventsArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToTaskEventsCalls(stub func(lager.Logger) (events.EventSource, error)) {
	fake.subscribeToTaskEventsMutex.Lock()
	defer fake.subscribeToTaskEventsMutex.Unlock()
	fake.SubscribeToTaskEventsStub = stub
}

func (fake *FakeInternalClient) SubscribeToTaskEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	argsForCall := fake.subscribeToTaskEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInternalClient) SubscribeToTaskEventsReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToTaskEventsMutex.Lock()
	defer fake.subscribeToTaskEventsMutex.Unlock()
	fake.SubscribeToTaskEventsStub = nil
	fake.subscribeToTaskEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToTaskEventsReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToTaskEventsMutex.Lock()
	defer fake.subscribeToTaskEventsMutex.Unlock()
	fake.SubscribeToTaskEventsStub = nil
	if fake.subscribeToTaskEventsReturnsOnCall == nil {
		fake.subscribeToTaskEventsReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToTaskEventsReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TaskByGuid(arg1 lager.Logger, arg2 string) (*models.Task, error) {
	fake.taskByGuidMutex.Lock()
	ret, specificReturn := fake.taskByGuidReturnsOnCall[len(fake.taskByGuidArgsForCall)]
	fake.taskByGuidArgsForCall = append(fake.taskByGuidArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("TaskByGuid", []interface{}{arg1, arg2})
	taskByGuidStubCopy := fake.TaskByGuidStub
	fake.taskByGuidMutex.Unlock()
	if taskByGuidStubCopy != nil {
		return taskByGuidStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.taskByGuidReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) TaskByGuidCallCount() int {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return len(fake.taskByGuidArgsForCall)
}

func (fake *FakeInternalClient) TaskByGuidCalls(stub func(lager.Logger, string) (*models.Task, error)) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = stub
}

func (fake *FakeInternalClient) TaskByGuidArgsForCall(i int) (lager.Logger, string) {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	argsForCall := fake.taskByGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) TaskByGuidReturns(result1 *models.Task, result2 error) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = nil
	fake.taskByGuidReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TaskByGuidReturnsOnCall(i int, result1 *models.Task, result2 error) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = nil
	if fake.taskByGuidReturnsOnCall == nil {
		fake.taskByGuidReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 error
		})
	}
	fake.taskByGuidReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) Tasks(arg1 lager.Logger) ([]*models.Task, error) {
	fake.tasksMutex.Lock()
	ret, specificReturn := fake.tasksReturnsOnCall[len(fake.tasksArgsForCall)]
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("Tasks", []interface{}{arg1})
	tasksStubCopy := fake.TasksStub
	fake.tasksMutex.Unlock()
	if tasksStubCopy != nil {
		return tasksStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tasksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeInternalClient) TasksCalls(stub func(lager.Logger) ([]*models.Task, error)) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = stub
}

func (fake *FakeInternalClient) TasksArgsForCall(i int) lager.Logger {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	argsForCall := fake.tasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInternalClient) TasksReturns(result1 []*models.Task, result2 error) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = nil
	if fake.tasksReturnsOnCall == nil {
		fake.tasksReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByCellID(arg1 lager.Logger, arg2 string) ([]*models.Task, error) {
	fake.tasksByCellIDMutex.Lock()
	ret, specificReturn := fake.tasksByCellIDReturnsOnCall[len(fake.tasksByCellIDArgsForCall)]
	fake.tasksByCellIDArgsForCall = append(fake.tasksByCellIDArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("TasksByCellID", []interface{}{arg1, arg2})
	tasksByCellIDStubCopy := fake.TasksByCellIDStub
	fake.tasksByCellIDMutex.Unlock()
	if tasksByCellIDStubCopy != nil {
		return tasksByCellIDStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tasksByCellIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) TasksByCellIDCallCount() int {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	return len(fake.tasksByCellIDArgsForCall)
}

func (fake *FakeInternalClient) TasksByCellIDCalls(stub func(lager.Logger, string) ([]*models.Task, error)) {
	fake.tasksByCellIDMutex.Lock()
	defer fake.tasksByCellIDMutex.Unlock()
	fake.TasksByCellIDStub = stub
}

func (fake *FakeInternalClient) TasksByCellIDArgsForCall(i int) (lager.Logger, string) {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	argsForCall := fake.tasksByCellIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) TasksByCellIDReturns(result1 []*models.Task, result2 error) {
	fake.tasksByCellIDMutex.Lock()
	defer fake.tasksByCellIDMutex.Unlock()
	fake.TasksByCellIDStub = nil
	fake.tasksByCellIDReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByCellIDReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksByCellIDMutex.Lock()
	defer fake.tasksByCellIDMutex.Unlock()
	fake.TasksByCellIDStub = nil
	if fake.tasksByCellIDReturnsOnCall == nil {
		fake.tasksByCellIDReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksByCellIDReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByDomain(arg1 lager.Logger, arg2 string) ([]*models.Task, error) {
	fake.tasksByDomainMutex.Lock()
	ret, specificReturn := fake.tasksByDomainReturnsOnCall[len(fake.tasksByDomainArgsForCall)]
	fake.tasksByDomainArgsForCall = append(fake.tasksByDomainArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("TasksByDomain", []interface{}{arg1, arg2})
	tasksByDomainStubCopy := fake.TasksByDomainStub
	fake.tasksByDomainMutex.Unlock()
	if tasksByDomainStubCopy != nil {
		return tasksByDomainStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tasksByDomainReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) TasksByDomainCallCount() int {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	return len(fake.tasksByDomainArgsForCall)
}

func (fake *FakeInternalClient) TasksByDomainCalls(stub func(lager.Logger, string) ([]*models.Task, error)) {
	fake.tasksByDomainMutex.Lock()
	defer fake.tasksByDomainMutex.Unlock()
	fake.TasksByDomainStub = stub
}

func (fake *FakeInternalClient) TasksByDomainArgsForCall(i int) (lager.Logger, string) {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	argsForCall := fake.tasksByDomainArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) TasksByDomainReturns(result1 []*models.Task, result2 error) {
	fake.tasksByDomainMutex.Lock()
	defer fake.tasksByDomainMutex.Unlock()
	fake.TasksByDomainStub = nil
	fake.tasksByDomainReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByDomainReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksByDomainMutex.Lock()
	defer fake.tasksByDomainMutex.Unlock()
	fake.TasksByDomainStub = nil
	if fake.tasksByDomainReturnsOnCall == nil {
		fake.tasksByDomainReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksByDomainReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksWithFilter(arg1 lager.Logger, arg2 models.TaskFilter) ([]*models.Task, error) {
	fake.tasksWithFilterMutex.Lock()
	ret, specificReturn := fake.tasksWithFilterReturnsOnCall[len(fake.tasksWithFilterArgsForCall)]
	fake.tasksWithFilterArgsForCall = append(fake.tasksWithFilterArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.TaskFilter
	}{arg1, arg2})
	fake.recordInvocation("TasksWithFilter", []interface{}{arg1, arg2})
	tasksWithFilterStubCopy := fake.TasksWithFilterStub
	fake.tasksWithFilterMutex.Unlock()
	if tasksWithFilterStubCopy != nil {
		return tasksWithFilterStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tasksWithFilterReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) TasksWithFilterCallCount() int {
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	return len(fake.tasksWithFilterArgsForCall)
}

func (fake *FakeInternalClient) TasksWithFilterCalls(stub func(lager.Logger, models.TaskFilter) ([]*models.Task, error)) {
	fake.tasksWithFilterMutex.Lock()
	defer fake.tasksWithFilterMutex.Unlock()
	fake.TasksWithFilterStub = stub
}

func (fake *FakeInternalClient) TasksWithFilterArgsForCall(i int) (lager.Logger, models.TaskFilter) {
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	argsForCall := fake.tasksWithFilterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) TasksWithFilterReturns(result1 []*models.Task, result2 error) {
	fake.tasksWithFilterMutex.Lock()
	defer fake.tasksWithFilterMutex.Unlock()
	fake.TasksWithFilterStub = nil
	fake.tasksWithFilterReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksWithFilterReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksWithFilterMutex.Lock()
	defer fake.tasksWithFilterMutex.Unlock()
	fake.TasksWithFilterStub = nil
	if fake.tasksWithFilterReturnsOnCall == nil {
		fake.tasksWithFilterReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksWithFilterReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) UpdateDesiredLRP(arg1 lager.Logger, arg2 string, arg3 *models.DesiredLRPUpdate) error {
	fake.updateDesiredLRPMutex.Lock()
	ret, specificReturn := fake.updateDesiredLRPReturnsOnCall[len(fake.updateDesiredLRPArgsForCall)]
	fake.updateDesiredLRPArgsForCall = append(fake.updateDesiredLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.DesiredLRPUpdate
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateDesiredLRP", []interface{}{arg1, arg2, arg3})
	updateDesiredLRPStubCopy := fake.UpdateDesiredLRPStub
	fake.updateDesiredLRPMutex.Unlock()
	if updateDesiredLRPStubCopy != nil {
		return updateDesiredLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateDesiredLRPReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) UpdateDesiredLRPCallCount() int {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return len(fake.updateDesiredLRPArgsForCall)
}

func (fake *FakeInternalClient) UpdateDesiredLRPCalls(stub func(lager.Logger, string, *models.DesiredLRPUpdate) error) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = stub
}

func (fake *FakeInternalClient) UpdateDesiredLRPArgsForCall(i int) (lager.Logger, string, *models.DesiredLRPUpdate) {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	argsForCall := fake.updateDesiredLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) UpdateDesiredLRPReturns(result1 error) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = nil
	fake.updateDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) UpdateDesiredLRPReturnsOnCall(i int, result1 error) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = nil
	if fake.updateDesiredLRPReturnsOnCall == nil {
		fake.updateDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateDesiredLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) UpsertDomain(arg1 lager.Logger, arg2 string, arg3 time.Duration) error {
	fake.upsertDomainMutex.Lock()
	ret, specificReturn := fake.upsertDomainReturnsOnCall[len(fake.upsertDomainArgsForCall)]
	fake.upsertDomainArgsForCall = append(fake.upsertDomainArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 time.Duration
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpsertDomain", []interface{}{arg1, arg2, arg3})
	upsertDomainStubCopy := fake.UpsertDomainStub
	fake.upsertDomainMutex.Unlock()
	if upsertDomainStubCopy != nil {
		return upsertDomainStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.upsertDomainReturns
	return fakeReturns.result1
}

func (fake *FakeInternalClient) UpsertDomainCallCount() int {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return len(fake.upsertDomainArgsForCall)
}

func (fake *FakeInternalClient) UpsertDomainCalls(stub func(lager.Logger, string, time.Duration) error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = stub
}

func (fake *FakeInternalClient) UpsertDomainArgsForCall(i int) (lager.Logger, string, time.Duration) {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	argsForCall := fake.upsertDomainArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) UpsertDomainReturns(result1 error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = nil
	fake.upsertDomainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) UpsertDomainReturnsOnCall(i int, result1 error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = nil
	if fake.upsertDomainReturnsOnCall == nil {
		fake.upsertDomainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upsertDomainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	fake.subscribeToInstanceEventsMutex.RLock()
	defer fake.subscribeToInstanceEventsMutex.RUnlock()
	fake.subscribeToInstanceEventsByCellIDMutex.RLock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.RUnlock()
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeInternalClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ bbs.InternalClient = new(FakeInternalClient)
