// Code generated by counterfeiter. DO NOT EDIT.
package fake_bbs

import (
	"sync"
	"time"

	"code.cloudfoundry.org/bbs"
	"code.cloudfoundry.org/bbs/events"
	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/lager"
)

type FakeClient struct {
	ActualLRPGroupByProcessGuidAndIndexStub        func(lager.Logger, string, int) (*models.ActualLRPGroup, error)
	actualLRPGroupByProcessGuidAndIndexMutex       sync.RWMutex
	actualLRPGroupByProcessGuidAndIndexArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 int
	}
	actualLRPGroupByProcessGuidAndIndexReturns struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupByProcessGuidAndIndexReturnsOnCall map[int]struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupsStub        func(lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsMutex       sync.RWMutex
	actualLRPGroupsArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}
	actualLRPGroupsReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupsByProcessGuidStub        func(lager.Logger, string) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsByProcessGuidMutex       sync.RWMutex
	actualLRPGroupsByProcessGuidArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	actualLRPGroupsByProcessGuidReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupsByProcessGuidReturnsOnCall map[int]struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPsStub        func(lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRP, error)
	actualLRPsMutex       sync.RWMutex
	actualLRPsArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}
	actualLRPsReturns struct {
		result1 []*models.ActualLRP
		result2 error
	}
	actualLRPsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRP
		result2 error
	}
	CancelTaskStub        func(lager.Logger, string) error
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	cancelTaskReturns struct {
		result1 error
	}
	cancelTaskReturnsOnCall map[int]struct {
		result1 error
	}
	CellsStub        func(lager.Logger) ([]*models.CellPresence, error)
	cellsMutex       sync.RWMutex
	cellsArgsForCall []struct {
		arg1 lager.Logger
	}
	cellsReturns struct {
		result1 []*models.CellPresence
		result2 error
	}
	cellsReturnsOnCall map[int]struct {
		result1 []*models.CellPresence
		result2 error
	}
	DeleteTaskStub        func(lager.Logger, string) error
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	deleteTaskReturns struct {
		result1 error
	}
	deleteTaskReturnsOnCall map[int]struct {
		result1 error
	}
	DesireLRPStub        func(lager.Logger, *models.DesiredLRP) error
	desireLRPMutex       sync.RWMutex
	desireLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.DesiredLRP
	}
	desireLRPReturns struct {
		result1 error
	}
	desireLRPReturnsOnCall map[int]struct {
		result1 error
	}
	DesireTaskStub        func(lager.Logger, string, string, *models.TaskDefinition) error
	desireTaskMutex       sync.RWMutex
	desireTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 *models.TaskDefinition
	}
	desireTaskReturns struct {
		result1 error
	}
	desireTaskReturnsOnCall map[int]struct {
		result1 error
	}
	DesiredLRPByProcessGuidStub        func(lager.Logger, string) (*models.DesiredLRP, error)
	desiredLRPByProcessGuidMutex       sync.RWMutex
	desiredLRPByProcessGuidArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	desiredLRPByProcessGuidReturns struct {
		result1 *models.DesiredLRP
		result2 error
	}
	desiredLRPByProcessGuidReturnsOnCall map[int]struct {
		result1 *models.DesiredLRP
		result2 error
	}
	DesiredLRPSchedulingInfosStub        func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)
	desiredLRPSchedulingInfosMutex       sync.RWMutex
	desiredLRPSchedulingInfosArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}
	desiredLRPSchedulingInfosReturns struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	desiredLRPSchedulingInfosReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	DesiredLRPsStub        func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)
	desiredLRPsMutex       sync.RWMutex
	desiredLRPsArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}
	desiredLRPsReturns struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	desiredLRPsReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	DomainsStub        func(lager.Logger) ([]string, error)
	domainsMutex       sync.RWMutex
	domainsArgsForCall []struct {
		arg1 lager.Logger
	}
	domainsReturns struct {
		result1 []string
		result2 error
	}
	domainsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	PingStub        func(lager.Logger) bool
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		arg1 lager.Logger
	}
	pingReturns struct {
		result1 bool
	}
	pingReturnsOnCall map[int]struct {
		result1 bool
	}
	RemoveDesiredLRPStub        func(lager.Logger, string) error
	removeDesiredLRPMutex       sync.RWMutex
	removeDesiredLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	removeDesiredLRPReturns struct {
		result1 error
	}
	removeDesiredLRPReturnsOnCall map[int]struct {
		result1 error
	}
	ResolvingTaskStub        func(lager.Logger, string) error
	resolvingTaskMutex       sync.RWMutex
	resolvingTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	resolvingTaskReturns struct {
		result1 error
	}
	resolvingTaskReturnsOnCall map[int]struct {
		result1 error
	}
	RetireActualLRPStub        func(lager.Logger, *models.ActualLRPKey) error
	retireActualLRPMutex       sync.RWMutex
	retireActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
	}
	retireActualLRPReturns struct {
		result1 error
	}
	retireActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	SubscribeToEventsStub        func(lager.Logger) (events.EventSource, error)
	subscribeToEventsMutex       sync.RWMutex
	subscribeToEventsArgsForCall []struct {
		arg1 lager.Logger
	}
	subscribeToEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToEventsReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToEventsByCellIDStub        func(lager.Logger, string) (events.EventSource, error)
	subscribeToEventsByCellIDMutex       sync.RWMutex
	subscribeToEventsByCellIDArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	subscribeToEventsByCellIDReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToEventsByCellIDReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToInstanceEventsStub        func(lager.Logger) (events.EventSource, error)
	subscribeToInstanceEventsMutex       sync.RWMutex
	subscribeToInstanceEventsArgsForCall []struct {
		arg1 lager.Logger
	}
	subscribeToInstanceEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToInstanceEventsReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToInstanceEventsByCellIDStub        func(lager.Logger, string) (events.EventSource, error)
	subscribeToInstanceEventsByCellIDMutex       sync.RWMutex
	subscribeToInstanceEventsByCellIDArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	subscribeToInstanceEventsByCellIDReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToInstanceEventsByCellIDReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToTaskEventsStub        func(lager.Logger) (events.EventSource, error)
	subscribeToTaskEventsMutex       sync.RWMutex
	subscribeToTaskEventsArgsForCall []struct {
		arg1 lager.Logger
	}
	subscribeToTaskEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToTaskEventsReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	TaskByGuidStub        func(lager.Logger, string) (*models.Task, error)
	taskByGuidMutex       sync.RWMutex
	taskByGuidArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	taskByGuidReturns struct {
		result1 *models.Task
		result2 error
	}
	taskByGuidReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 error
	}
	TasksStub        func(lager.Logger) ([]*models.Task, error)
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct {
		arg1 lager.Logger
	}
	tasksReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksByCellIDStub        func(lager.Logger, string) ([]*models.Task, error)
	tasksByCellIDMutex       sync.RWMutex
	tasksByCellIDArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	tasksByCellIDReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksByCellIDReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksByDomainStub        func(lager.Logger, string) ([]*models.Task, error)
	tasksByDomainMutex       sync.RWMutex
	tasksByDomainArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	tasksByDomainReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksByDomainReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksWithFilterStub        func(lager.Logger, models.TaskFilter) ([]*models.Task, error)
	tasksWithFilterMutex       sync.RWMutex
	tasksWithFilterArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.TaskFilter
	}
	tasksWithFilterReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksWithFilterReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	UpdateDesiredLRPStub        func(lager.Logger, string, *models.DesiredLRPUpdate) error
	updateDesiredLRPMutex       sync.RWMutex
	updateDesiredLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.DesiredLRPUpdate
	}
	updateDesiredLRPReturns struct {
		result1 error
	}
	updateDesiredLRPReturnsOnCall map[int]struct {
		result1 error
	}
	UpsertDomainStub        func(lager.Logger, string, time.Duration) error
	upsertDomainMutex       sync.RWMutex
	upsertDomainArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 time.Duration
	}
	upsertDomainReturns struct {
		result1 error
	}
	upsertDomainReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) ActualLRPGroupByProcessGuidAndIndex(arg1 lager.Logger, arg2 string, arg3 int) (*models.ActualLRPGroup, error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall[len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)]
	fake.actualLRPGroupByProcessGuidAndIndexArgsForCall = append(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("ActualLRPGroupByProcessGuidAndIndex", []interface{}{arg1, arg2, arg3})
	actualLRPGroupByProcessGuidAndIndexStubCopy := fake.ActualLRPGroupByProcessGuidAndIndexStub
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	if actualLRPGroupByProcessGuidAndIndexStubCopy != nil {
		return actualLRPGroupByProcessGuidAndIndexStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.actualLRPGroupByProcessGuidAndIndexReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ActualLRPGroupByProcessGuidAndIndexCallCount() int {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)
}

func (fake *FakeClient) ActualLRPGroupByProcessGuidAndIndexCalls(stub func(lager.Logger, string, int) (*models.ActualLRPGroup, error)) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	fake.ActualLRPGroupByProcessGuidAndIndexStub = stub
}

func (fake *FakeClient) ActualLRPGroupByProcessGuidAndIndexArgsForCall(i int) (lager.Logger, string, int) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	argsForCall := fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ActualLRPGroupByProcessGuidAndIndexReturns(result1 *models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	fake.actualLRPGroupByProcessGuidAndIndexReturns = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ActualLRPGroupByProcessGuidAndIndexReturnsOnCall(i int, result1 *models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	if fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall == nil {
		fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall[i] = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ActualLRPGroups(arg1 lager.Logger, arg2 models.ActualLRPFilter) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupsReturnsOnCall[len(fake.actualLRPGroupsArgsForCall)]
	fake.actualLRPGroupsArgsForCall = append(fake.actualLRPGroupsArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("ActualLRPGroups", []interface{}{arg1, arg2})
	actualLRPGroupsStubCopy := fake.ActualLRPGroupsStub
	fake.actualLRPGroupsMutex.Unlock()
	if actualLRPGroupsStubCopy != nil {
		return actualLRPGroupsStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.actualLRPGroupsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ActualLRPGroupsCallCount() int {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return len(fake.actualLRPGroupsArgsForCall)
}

func (fake *FakeClient) ActualLRPGroupsCalls(stub func(lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRPGroup, error)) {
	fake.actualLRPGroupsMutex.Lock()
	defer fake.actualLRPGroupsMutex.Unlock()
	fake.ActualLRPGroupsStub = stub
}

func (fake *FakeClient) ActualLRPGroupsArgsForCall(i int) (lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	argsForCall := fake.actualLRPGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ActualLRPGroupsReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsMutex.Lock()
	defer fake.actualLRPGroupsMutex.Unlock()
	fake.ActualLRPGroupsStub = nil
	fake.actualLRPGroupsReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ActualLRPGroupsReturnsOnCall(i int, result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsMutex.Lock()
	defer fake.actualLRPGroupsMutex.Unlock()
	fake.ActualLRPGroupsStub = nil
	if fake.actualLRPGroupsReturnsOnCall == nil {
		fake.actualLRPGroupsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ActualLRPGroupsByProcessGuid(arg1 lager.Logger, arg2 string) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupsByProcessGuidReturnsOnCall[len(fake.actualLRPGroupsByProcessGuidArgsForCall)]
	fake.actualLRPGroupsByProcessGuidArgsForCall = append(fake.actualLRPGroupsByProcessGuidArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ActualLRPGroupsByProcessGuid", []interface{}{arg1, arg2})
	actualLRPGroupsByProcessGuidStubCopy := fake.ActualLRPGroupsByProcessGuidStub
	fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	if actualLRPGroupsByProcessGuidStubCopy != nil {
		return actualLRPGroupsByProcessGuidStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.actualLRPGroupsByProcessGuidReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ActualLRPGroupsByProcessGuidCallCount() int {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return len(fake.actualLRPGroupsByProcessGuidArgsForCall)
}

func (fake *FakeClient) ActualLRPGroupsByProcessGuidCalls(stub func(lager.Logger, string) ([]*models.ActualLRPGroup, error)) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	defer fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	fake.ActualLRPGroupsByProcessGuidStub = stub
}

func (fake *FakeClient) ActualLRPGroupsByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	argsForCall := fake.actualLRPGroupsByProcessGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ActualLRPGroupsByProcessGuidReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	defer fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	fake.ActualLRPGroupsByProcessGuidStub = nil
	fake.actualLRPGroupsByProcessGuidReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ActualLRPGroupsByProcessGuidReturnsOnCall(i int, result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	defer fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	fake.ActualLRPGroupsByProcessGuidStub = nil
	if fake.actualLRPGroupsByProcessGuidReturnsOnCall == nil {
		fake.actualLRPGroupsByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupsByProcessGuidReturnsOnCall[i] = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ActualLRPs(arg1 lager.Logger, arg2 models.ActualLRPFilter) ([]*models.ActualLRP, error) {
	fake.actualLRPsMutex.Lock()
	ret, specificReturn := fake.actualLRPsReturnsOnCall[len(fake.actualLRPsArgsForCall)]
	fake.actualLRPsArgsForCall = append(fake.actualLRPsArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("ActualLRPs", []interface{}{arg1, arg2})
	actualLRPsStubCopy := fake.ActualLRPsStub
	fake.actualLRPsMutex.Unlock()
	if actualLRPsStubCopy != nil {
		return actualLRPsStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.actualLRPsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ActualLRPsCallCount() int {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	return len(fake.actualLRPsArgsForCall)
}

func (fake *FakeClient) ActualLRPsCalls(stub func(lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRP, error)) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = stub
}

func (fake *FakeClient) ActualLRPsArgsForCall(i int) (lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	argsForCall := fake.actualLRPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ActualLRPsReturns(result1 []*models.ActualLRP, result2 error) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = nil
	fake.actualLRPsReturns = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ActualLRPsReturnsOnCall(i int, result1 []*models.ActualLRP, result2 error) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = nil
	if fake.actualLRPsReturnsOnCall == nil {
		fake.actualLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRP
			result2 error
		})
	}
	fake.actualLRPsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CancelTask(arg1 lager.Logger, arg2 string) error {
	fake.cancelTaskMutex.Lock()
	ret, specificReturn := fake.cancelTaskReturnsOnCall[len(fake.cancelTaskArgsForCall)]
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CancelTask", []interface{}{arg1, arg2})
	cancelTaskStubCopy := fake.CancelTaskStub
	fake.cancelTaskMutex.Unlock()
	if cancelTaskStubCopy != nil {
		return cancelTaskStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cancelTaskReturns
	return fakeReturns.result1
}

func (fake *FakeClient) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeClient) CancelTaskCalls(stub func(lager.Logger, string) error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = stub
}

func (fake *FakeClient) CancelTaskArgsForCall(i int) (lager.Logger, string) {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	argsForCall := fake.cancelTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CancelTaskReturns(result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CancelTaskReturnsOnCall(i int, result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	if fake.cancelTaskReturnsOnCall == nil {
		fake.cancelTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Cells(arg1 lager.Logger) ([]*models.CellPresence, error) {
	fake.cellsMutex.Lock()
	ret, specificReturn := fake.cellsReturnsOnCall[len(fake.cellsArgsForCall)]
	fake.cellsArgsForCall = append(fake.cellsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("Cells", []interface{}{arg1})
	cellsStubCopy := fake.CellsStub
	fake.cellsMutex.Unlock()
	if cellsStubCopy != nil {
		return cellsStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.cellsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CellsCallCount() int {
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	return len(fake.cellsArgsForCall)
}

func (fake *FakeClient) CellsCalls(stub func(lager.Logger) ([]*models.CellPresence, error)) {
	fake.cellsMutex.Lock()
	defer fake.cellsMutex.Unlock()
	fake.CellsStub = stub
}

func (fake *FakeClient) CellsArgsForCall(i int) lager.Logger {
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	argsForCall := fake.cellsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CellsReturns(result1 []*models.CellPresence, result2 error) {
	fake.cellsMutex.Lock()
	defer fake.cellsMutex.Unlock()
	fake.CellsStub = nil
	fake.cellsReturns = struct {
		result1 []*models.CellPresence
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CellsReturnsOnCall(i int, result1 []*models.CellPresence, result2 error) {
	fake.cellsMutex.Lock()
	defer fake.cellsMutex.Unlock()
	fake.CellsStub = nil
	if fake.cellsReturnsOnCall == nil {
		fake.cellsReturnsOnCall = make(map[int]struct {
			result1 []*models.CellPresence
			result2 error
		})
	}
	fake.cellsReturnsOnCall[i] = struct {
		result1 []*models.CellPresence
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteTask(arg1 lager.Logger, arg2 string) error {
	fake.deleteTaskMutex.Lock()
	ret, specificReturn := fake.deleteTaskReturnsOnCall[len(fake.deleteTaskArgsForCall)]
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("DeleteTask", []interface{}{arg1, arg2})
	deleteTaskStubCopy := fake.DeleteTaskStub
	fake.deleteTaskMutex.Unlock()
	if deleteTaskStubCopy != nil {
		return deleteTaskStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteTaskReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeClient) DeleteTaskCalls(stub func(lager.Logger, string) error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = stub
}

func (fake *FakeClient) DeleteTaskArgsForCall(i int) (lager.Logger, string) {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	argsForCall := fake.deleteTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DeleteTaskReturns(result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteTaskReturnsOnCall(i int, result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	if fake.deleteTaskReturnsOnCall == nil {
		fake.deleteTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DesireLRP(arg1 lager.Logger, arg2 *models.DesiredLRP) error {
	fake.desireLRPMutex.Lock()
	ret, specificReturn := fake.desireLRPReturnsOnCall[len(fake.desireLRPArgsForCall)]
	fake.desireLRPArgsForCall = append(fake.desireLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.DesiredLRP
	}{arg1, arg2})
	fake.recordInvocation("DesireLRP", []interface{}{arg1, arg2})
	desireLRPStubCopy := fake.DesireLRPStub
	fake.desireLRPMutex.Unlock()
	if desireLRPStubCopy != nil {
		return desireLRPStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.desireLRPReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DesireLRPCallCount() int {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return len(fake.desireLRPArgsForCall)
}

func (fake *FakeClient) DesireLRPCalls(stub func(lager.Logger, *models.DesiredLRP) error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = stub
}

func (fake *FakeClient) DesireLRPArgsForCall(i int) (lager.Logger, *models.DesiredLRP) {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	argsForCall := fake.desireLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DesireLRPReturns(result1 error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = nil
	fake.desireLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DesireLRPReturnsOnCall(i int, result1 error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = nil
	if fake.desireLRPReturnsOnCall == nil {
		fake.desireLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.desireLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DesireTask(arg1 lager.Logger, arg2 string, arg3 string, arg4 *models.TaskDefinition) error {
	fake.desireTaskMutex.Lock()
	ret, specificReturn := fake.desireTaskReturnsOnCall[len(fake.desireTaskArgsForCall)]
	fake.desireTaskArgsForCall = append(fake.desireTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 *models.TaskDefinition
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("DesireTask", []interface{}{arg1, arg2, arg3, arg4})
	desireTaskStubCopy := fake.DesireTaskStub
	fake.desireTaskMutex.Unlock()
	if desireTaskStubCopy != nil {
		return desireTaskStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.desireTaskReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DesireTaskCallCount() int {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return len(fake.desireTaskArgsForCall)
}

func (fake *FakeClient) DesireTaskCalls(stub func(lager.Logger, string, string, *models.TaskDefinition) error) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = stub
}

func (fake *FakeClient) DesireTaskArgsForCall(i int) (lager.Logger, string, string, *models.TaskDefinition) {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	argsForCall := fake.desireTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) DesireTaskReturns(result1 error) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = nil
	fake.desireTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DesireTaskReturnsOnCall(i int, result1 error) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = nil
	if fake.desireTaskReturnsOnCall == nil {
		fake.desireTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.desireTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DesiredLRPByProcessGuid(arg1 lager.Logger, arg2 string) (*models.DesiredLRP, error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	ret, specificReturn := fake.desiredLRPByProcessGuidReturnsOnCall[len(fake.desiredLRPByProcessGuidArgsForCall)]
	fake.desiredLRPByProcessGuidArgsForCall = append(fake.desiredLRPByProcessGuidArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("DesiredLRPByProcessGuid", []interface{}{arg1, arg2})
	desiredLRPByProcessGuidStubCopy := fake.DesiredLRPByProcessGuidStub
	fake.desiredLRPByProcessGuidMutex.Unlock()
	if desiredLRPByProcessGuidStubCopy != nil {
		return desiredLRPByProcessGuidStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.desiredLRPByProcessGuidReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DesiredLRPByProcessGuidCallCount() int {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return len(fake.desiredLRPByProcessGuidArgsForCall)
}

func (fake *FakeClient) DesiredLRPByProcessGuidCalls(stub func(lager.Logger, string) (*models.DesiredLRP, error)) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = stub
}

func (fake *FakeClient) DesiredLRPByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	argsForCall := fake.desiredLRPByProcessGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DesiredLRPByProcessGuidReturns(result1 *models.DesiredLRP, result2 error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = nil
	fake.desiredLRPByProcessGuidReturns = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DesiredLRPByProcessGuidReturnsOnCall(i int, result1 *models.DesiredLRP, result2 error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = nil
	if fake.desiredLRPByProcessGuidReturnsOnCall == nil {
		fake.desiredLRPByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 *models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPByProcessGuidReturnsOnCall[i] = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DesiredLRPSchedulingInfos(arg1 lager.Logger, arg2 models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	ret, specificReturn := fake.desiredLRPSchedulingInfosReturnsOnCall[len(fake.desiredLRPSchedulingInfosArgsForCall)]
	fake.desiredLRPSchedulingInfosArgsForCall = append(fake.desiredLRPSchedulingInfosArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("DesiredLRPSchedulingInfos", []interface{}{arg1, arg2})
	desiredLRPSchedulingInfosStubCopy := fake.DesiredLRPSchedulingInfosStub
	fake.desiredLRPSchedulingInfosMutex.Unlock()
	if desiredLRPSchedulingInfosStubCopy != nil {
		return desiredLRPSchedulingInfosStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.desiredLRPSchedulingInfosReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DesiredLRPSchedulingInfosCallCount() int {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return len(fake.desiredLRPSchedulingInfosArgsForCall)
}

func (fake *FakeClient) DesiredLRPSchedulingInfosCalls(stub func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = stub
}

func (fake *FakeClient) DesiredLRPSchedulingInfosArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	argsForCall := fake.desiredLRPSchedulingInfosArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DesiredLRPSchedulingInfosReturns(result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = nil
	fake.desiredLRPSchedulingInfosReturns = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DesiredLRPSchedulingInfosReturnsOnCall(i int, result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = nil
	if fake.desiredLRPSchedulingInfosReturnsOnCall == nil {
		fake.desiredLRPSchedulingInfosReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRPSchedulingInfo
			result2 error
		})
	}
	fake.desiredLRPSchedulingInfosReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DesiredLRPs(arg1 lager.Logger, arg2 models.DesiredLRPFilter) ([]*models.DesiredLRP, error) {
	fake.desiredLRPsMutex.Lock()
	ret, specificReturn := fake.desiredLRPsReturnsOnCall[len(fake.desiredLRPsArgsForCall)]
	fake.desiredLRPsArgsForCall = append(fake.desiredLRPsArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("DesiredLRPs", []interface{}{arg1, arg2})
	desiredLRPsStubCopy := fake.DesiredLRPsStub
	fake.desiredLRPsMutex.Unlock()
	if desiredLRPsStubCopy != nil {
		return desiredLRPsStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.desiredLRPsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DesiredLRPsCallCount() int {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return len(fake.desiredLRPsArgsForCall)
}

func (fake *FakeClient) DesiredLRPsCalls(stub func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = stub
}

func (fake *FakeClient) DesiredLRPsArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	argsForCall := fake.desiredLRPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DesiredLRPsReturns(result1 []*models.DesiredLRP, result2 error) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = nil
	fake.desiredLRPsReturns = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DesiredLRPsReturnsOnCall(i int, result1 []*models.DesiredLRP, result2 error) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = nil
	if fake.desiredLRPsReturnsOnCall == nil {
		fake.desiredLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPsReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Domains(arg1 lager.Logger) ([]string, error) {
	fake.domainsMutex.Lock()
	ret, specificReturn := fake.domainsReturnsOnCall[len(fake.domainsArgsForCall)]
	fake.domainsArgsForCall = append(fake.domainsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("Domains", []interface{}{arg1})
	domainsStubCopy := fake.DomainsStub
	fake.domainsMutex.Unlock()
	if domainsStubCopy != nil {
		return domainsStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.domainsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DomainsCallCount() int {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	return len(fake.domainsArgsForCall)
}

func (fake *FakeClient) DomainsCalls(stub func(lager.Logger) ([]string, error)) {
	fake.domainsMutex.Lock()
	defer fake.domainsMutex.Unlock()
	fake.DomainsStub = stub
}

func (fake *FakeClient) DomainsArgsForCall(i int) lager.Logger {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	argsForCall := fake.domainsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DomainsReturns(result1 []string, result2 error) {
	fake.domainsMutex.Lock()
	defer fake.domainsMutex.Unlock()
	fake.DomainsStub = nil
	fake.domainsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DomainsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.domainsMutex.Lock()
	defer fake.domainsMutex.Unlock()
	fake.DomainsStub = nil
	if fake.domainsReturnsOnCall == nil {
		fake.domainsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.domainsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Ping(arg1 lager.Logger) bool {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("Ping", []interface{}{arg1})
	pingStubCopy := fake.PingStub
	fake.pingMutex.Unlock()
	if pingStubCopy != nil {
		return pingStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pingReturns
	return fakeReturns.result1
}

func (fake *FakeClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeClient) PingCalls(stub func(lager.Logger) bool) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *FakeClient) PingArgsForCall(i int) lager.Logger {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	argsForCall := fake.pingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PingReturns(result1 bool) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) PingReturnsOnCall(i int, result1 bool) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) RemoveDesiredLRP(arg1 lager.Logger, arg2 string) error {
	fake.removeDesiredLRPMutex.Lock()
	ret, specificReturn := fake.removeDesiredLRPReturnsOnCall[len(fake.removeDesiredLRPArgsForCall)]
	fake.removeDesiredLRPArgsForCall = append(fake.removeDesiredLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RemoveDesiredLRP", []interface{}{arg1, arg2})
	removeDesiredLRPStubCopy := fake.RemoveDesiredLRPStub
	fake.removeDesiredLRPMutex.Unlock()
	if removeDesiredLRPStubCopy != nil {
		return removeDesiredLRPStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeDesiredLRPReturns
	return fakeReturns.result1
}

func (fake *FakeClient) RemoveDesiredLRPCallCount() int {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return len(fake.removeDesiredLRPArgsForCall)
}

func (fake *FakeClient) RemoveDesiredLRPCalls(stub func(lager.Logger, string) error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = stub
}

func (fake *FakeClient) RemoveDesiredLRPArgsForCall(i int) (lager.Logger, string) {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	argsForCall := fake.removeDesiredLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) RemoveDesiredLRPReturns(result1 error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = nil
	fake.removeDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RemoveDesiredLRPReturnsOnCall(i int, result1 error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = nil
	if fake.removeDesiredLRPReturnsOnCall == nil {
		fake.removeDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeDesiredLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ResolvingTask(arg1 lager.Logger, arg2 string) error {
	fake.resolvingTaskMutex.Lock()
	ret, specificReturn := fake.resolvingTaskReturnsOnCall[len(fake.resolvingTaskArgsForCall)]
	fake.resolvingTaskArgsForCall = append(fake.resolvingTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ResolvingTask", []interface{}{arg1, arg2})
	resolvingTaskStubCopy := fake.ResolvingTaskStub
	fake.resolvingTaskMutex.Unlock()
	if resolvingTaskStubCopy != nil {
		return resolvingTaskStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.resolvingTaskReturns
	return fakeReturns.result1
}

func (fake *FakeClient) ResolvingTaskCallCount() int {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return len(fake.resolvingTaskArgsForCall)
}

func (fake *FakeClient) ResolvingTaskCalls(stub func(lager.Logger, string) error) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = stub
}

func (fake *FakeClient) ResolvingTaskArgsForCall(i int) (lager.Logger, string) {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	argsForCall := fake.resolvingTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ResolvingTaskReturns(result1 error) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = nil
	fake.resolvingTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ResolvingTaskReturnsOnCall(i int, result1 error) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = nil
	if fake.resolvingTaskReturnsOnCall == nil {
		fake.resolvingTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resolvingTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RetireActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey) error {
	fake.retireActualLRPMutex.Lock()
	ret, specificReturn := fake.retireActualLRPReturnsOnCall[len(fake.retireActualLRPArgsForCall)]
	fake.retireActualLRPArgsForCall = append(fake.retireActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
	}{arg1, arg2})
	fake.recordInvocation("RetireActualLRP", []interface{}{arg1, arg2})
	retireActualLRPStubCopy := fake.RetireActualLRPStub
	fake.retireActualLRPMutex.Unlock()
	if retireActualLRPStubCopy != nil {
		return retireActualLRPStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.retireActualLRPReturns
	return fakeReturns.result1
}

func (fake *FakeClient) RetireActualLRPCallCount() int {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	return len(fake.retireActualLRPArgsForCall)
}

func (fake *FakeClient) RetireActualLRPCalls(stub func(lager.Logger, *models.ActualLRPKey) error) {
	fake.retireActualLRPMutex.Lock()
	defer fake.retireActualLRPMutex.Unlock()
	fake.RetireActualLRPStub = stub
}

func (fake *FakeClient) RetireActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	argsForCall := fake.retireActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) RetireActualLRPReturns(result1 error) {
	fake.retireActualLRPMutex.Lock()
	defer fake.retireActualLRPMutex.Unlock()
	fake.RetireActualLRPStub = nil
	fake.retireActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RetireActualLRPReturnsOnCall(i int, result1 error) {
	fake.retireActualLRPMutex.Lock()
	defer fake.retireActualLRPMutex.Unlock()
	fake.RetireActualLRPStub = nil
	if fake.retireActualLRPReturnsOnCall == nil {
		fake.retireActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.retireActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) SubscribeToEvents(arg1 lager.Logger) (events.EventSource, error) {
	fake.subscribeToEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToEventsReturnsOnCall[len(fake.subscribeToEventsArgsForCall)]
	fake.subscribeToEventsArgsForCall = append(fake.subscribeToEventsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("SubscribeToEvents", []interface{}{arg1})
	subscribeToEventsStubCopy := fake.SubscribeToEventsStub
	fake.subscribeToEventsMutex.Unlock()
	if subscribeToEventsStubCopy != nil {
		return subscribeToEventsStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToEventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SubscribeToEventsCallCount() int {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return len(fake.subscribeToEventsArgsForCall)
}

func (fake *FakeClient) SubscribeToEventsCalls(stub func(lager.Logger) (events.EventSource, error)) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = stub
}

func (fake *FakeClient) SubscribeToEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	argsForCall := fake.subscribeToEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SubscribeToEventsReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = nil
	fake.subscribeToEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToEventsReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = nil
	if fake.subscribeToEventsReturnsOnCall == nil {
		fake.subscribeToEventsReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToEventsReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToEventsByCellID(arg1 lager.Logger, arg2 string) (events.EventSource, error) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	ret, specificReturn := fake.subscribeToEventsByCellIDReturnsOnCall[len(fake.subscribeToEventsByCellIDArgsForCall)]
	fake.subscribeToEventsByCellIDArgsForCall = append(fake.subscribeToEventsByCellIDArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SubscribeToEventsByCellID", []interface{}{arg1, arg2})
	subscribeToEventsByCellIDStubCopy := fake.SubscribeToEventsByCellIDStub
	fake.subscribeToEventsByCellIDMutex.Unlock()
	if subscribeToEventsByCellIDStubCopy != nil {
		return subscribeToEventsByCellIDStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToEventsByCellIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SubscribeToEventsByCellIDCallCount() int {
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	return len(fake.subscribeToEventsByCellIDArgsForCall)
}

func (fake *FakeClient) SubscribeToEventsByCellIDCalls(stub func(lager.Logger, string) (events.EventSource, error)) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	defer fake.subscribeToEventsByCellIDMutex.Unlock()
	fake.SubscribeToEventsByCellIDStub = stub
}

func (fake *FakeClient) SubscribeToEventsByCellIDArgsForCall(i int) (lager.Logger, string) {
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	argsForCall := fake.subscribeToEventsByCellIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SubscribeToEventsByCellIDReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	defer fake.subscribeToEventsByCellIDMutex.Unlock()
	fake.SubscribeToEventsByCellIDStub = nil
	fake.subscribeToEventsByCellIDReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToEventsByCellIDReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	defer fake.subscribeToEventsByCellIDMutex.Unlock()
	fake.SubscribeToEventsByCellIDStub = nil
	if fake.subscribeToEventsByCellIDReturnsOnCall == nil {
		fake.subscribeToEventsByCellIDReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToEventsByCellIDReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToInstanceEvents(arg1 lager.Logger) (events.EventSource, error) {
	fake.subscribeToInstanceEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToInstanceEventsReturnsOnCall[len(fake.subscribeToInstanceEventsArgsForCall)]
	fake.subscribeToInstanceEventsArgsForCall = append(fake.subscribeToInstanceEventsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("SubscribeToInstanceEvents", []interface{}{arg1})
	subscribeToInstanceEventsStubCopy := fake.SubscribeToInstanceEventsStub
	fake.subscribeToInstanceEventsMutex.Unlock()
	if subscribeToInstanceEventsStubCopy != nil {
		return subscribeToInstanceEventsStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToInstanceEventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SubscribeToInstanceEventsCallCount() int {
	fake.subscribeToInstanceEventsMutex.RLock()
	defer fake.subscribeToInstanceEventsMutex.RUnlock()
	return len(fake.subscribeToInstanceEventsArgsForCall)
}

func (fake *FakeClient) SubscribeToInstanceEventsCalls(stub func(lager.Logger) (events.EventSource, error)) {
	fake.subscribeToInstanceEventsMutex.Lock()
	defer fake.subscribeToInstanceEventsMutex.Unlock()
	fake.SubscribeToInstanceEventsStub = stub
}

func (fake *FakeClient) SubscribeToInstanceEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToInstanceEventsMutex.RLock()
	defer fake.subscribeToInstanceEventsMutex.RUnlock()
	argsForCall := fake.subscribeToInstanceEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SubscribeToInstanceEventsReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsMutex.Lock()
	defer fake.subscribeToInstanceEventsMutex.Unlock()
	fake.SubscribeToInstanceEventsStub = nil
	fake.subscribeToInstanceEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToInstanceEventsReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsMutex.Lock()
	defer fake.subscribeToInstanceEventsMutex.Unlock()
	fake.SubscribeToInstanceEventsStub = nil
	if fake.subscribeToInstanceEventsReturnsOnCall == nil {
		fake.subscribeToInstanceEventsReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToInstanceEventsReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToInstanceEventsByCellID(arg1 lager.Logger, arg2 string) (events.EventSource, error) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	ret, specificReturn := fake.subscribeToInstanceEventsByCellIDReturnsOnCall[len(fake.subscribeToInstanceEventsByCellIDArgsForCall)]
	fake.subscribeToInstanceEventsByCellIDArgsForCall = append(fake.subscribeToInstanceEventsByCellIDArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SubscribeToInstanceEventsByCellID", []interface{}{arg1, arg2})
	subscribeToInstanceEventsByCellIDStubCopy := fake.SubscribeToInstanceEventsByCellIDStub
	fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	if subscribeToInstanceEventsByCellIDStubCopy != nil {
		return subscribeToInstanceEventsByCellIDStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToInstanceEventsByCellIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SubscribeToInstanceEventsByCellIDCallCount() int {
	fake.subscribeToInstanceEventsByCellIDMutex.RLock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.RUnlock()
	return len(fake.subscribeToInstanceEventsByCellIDArgsForCall)
}

func (fake *FakeClient) SubscribeToInstanceEventsByCellIDCalls(stub func(lager.Logger, string) (events.EventSource, error)) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	fake.SubscribeToInstanceEventsByCellIDStub = stub
}

func (fake *FakeClient) SubscribeToInstanceEventsByCellIDArgsForCall(i int) (lager.Logger, string) {
	fake.subscribeToInstanceEventsByCellIDMutex.RLock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.RUnlock()
	argsForCall := fake.subscribeToInstanceEventsByCellIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SubscribeToInstanceEventsByCellIDReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	fake.SubscribeToInstanceEventsByCellIDStub = nil
	fake.subscribeToInstanceEventsByCellIDReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToInstanceEventsByCellIDReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	fake.SubscribeToInstanceEventsByCellIDStub = nil
	if fake.subscribeToInstanceEventsByCellIDReturnsOnCall == nil {
		fake.subscribeToInstanceEventsByCellIDReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToInstanceEventsByCellIDReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToTaskEvents(arg1 lager.Logger) (events.EventSource, error) {
	fake.subscribeToTaskEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToTaskEventsReturnsOnCall[len(fake.subscribeToTaskEventsArgsForCall)]
	fake.subscribeToTaskEventsArgsForCall = append(fake.subscribeToTaskEventsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("SubscribeToTaskEvents", []interface{}{arg1})
	subscribeToTaskEventsStubCopy := fake.SubscribeToTaskEventsStub
	fake.subscribeToTaskEventsMutex.Unlock()
	if subscribeToTaskEventsStubCopy != nil {
		return subscribeToTaskEventsStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToTaskEventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SubscribeToTaskEventsCallCount() int {
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	return len(fake.subscribeToTaskEventsArgsForCall)
}

func (fake *FakeClient) SubscribeToTaskEventsCalls(stub func(lager.Logger) (events.EventSource, error)) {
	fake.subscribeToTaskEventsMutex.Lock()
	defer fake.subscribeToTaskEventsMutex.Unlock()
	fake.SubscribeToTaskEventsStub = stub
}

func (fake *FakeClient) SubscribeToTaskEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	argsForCall := fake.subscribeToTaskEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SubscribeToTaskEventsReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToTaskEventsMutex.Lock()
	defer fake.subscribeToTaskEventsMutex.Unlock()
	fake.SubscribeToTaskEventsStub = nil
	fake.subscribeToTaskEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToTaskEventsReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToTaskEventsMutex.Lock()
	defer fake.subscribeToTaskEventsMutex.Unlock()
	fake.SubscribeToTaskEventsStub = nil
	if fake.subscribeToTaskEventsReturnsOnCall == nil {
		fake.subscribeToTaskEventsReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToTaskEventsReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TaskByGuid(arg1 lager.Logger, arg2 string) (*models.Task, error) {
	fake.taskByGuidMutex.Lock()
	ret, specificReturn := fake.taskByGuidReturnsOnCall[len(fake.taskByGuidArgsForCall)]
	fake.taskByGuidArgsForCall = append(fake.taskByGuidArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("TaskByGuid", []interface{}{arg1, arg2})
	taskByGuidStubCopy := fake.TaskByGuidStub
	fake.taskByGuidMutex.Unlock()
	if taskByGuidStubCopy != nil {
		return taskByGuidStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.taskByGuidReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) TaskByGuidCallCount() int {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return len(fake.taskByGuidArgsForCall)
}

func (fake *FakeClient) TaskByGuidCalls(stub func(lager.Logger, string) (*models.Task, error)) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = stub
}

func (fake *FakeClient) TaskByGuidArgsForCall(i int) (lager.Logger, string) {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	argsForCall := fake.taskByGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TaskByGuidReturns(result1 *models.Task, result2 error) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = nil
	fake.taskByGuidReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TaskByGuidReturnsOnCall(i int, result1 *models.Task, result2 error) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = nil
	if fake.taskByGuidReturnsOnCall == nil {
		fake.taskByGuidReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 error
		})
	}
	fake.taskByGuidReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Tasks(arg1 lager.Logger) ([]*models.Task, error) {
	fake.tasksMutex.Lock()
	ret, specificReturn := fake.tasksReturnsOnCall[len(fake.tasksArgsForCall)]
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	fake.recordInvocation("Tasks", []interface{}{arg1})
	tasksStubCopy := fake.TasksStub
	fake.tasksMutex.Unlock()
	if tasksStubCopy != nil {
		return tasksStubCopy(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tasksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeClient) TasksCalls(stub func(lager.Logger) ([]*models.Task, error)) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = stub
}

func (fake *FakeClient) TasksArgsForCall(i int) lager.Logger {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	argsForCall := fake.tasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) TasksReturns(result1 []*models.Task, result2 error) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TasksReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = nil
	if fake.tasksReturnsOnCall == nil {
		fake.tasksReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TasksByCellID(arg1 lager.Logger, arg2 string) ([]*models.Task, error) {
	fake.tasksByCellIDMutex.Lock()
	ret, specificReturn := fake.tasksByCellIDReturnsOnCall[len(fake.tasksByCellIDArgsForCall)]
	fake.tasksByCellIDArgsForCall = append(fake.tasksByCellIDArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("TasksByCellID", []interface{}{arg1, arg2})
	tasksByCellIDStubCopy := fake.TasksByCellIDStub
	fake.tasksByCellIDMutex.Unlock()
	if tasksByCellIDStubCopy != nil {
		return tasksByCellIDStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tasksByCellIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) TasksByCellIDCallCount() int {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	return len(fake.tasksByCellIDArgsForCall)
}

func (fake *FakeClient) TasksByCellIDCalls(stub func(lager.Logger, string) ([]*models.Task, error)) {
	fake.tasksByCellIDMutex.Lock()
	defer fake.tasksByCellIDMutex.Unlock()
	fake.TasksByCellIDStub = stub
}

func (fake *FakeClient) TasksByCellIDArgsForCall(i int) (lager.Logger, string) {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	argsForCall := fake.tasksByCellIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TasksByCellIDReturns(result1 []*models.Task, result2 error) {
	fake.tasksByCellIDMutex.Lock()
	defer fake.tasksByCellIDMutex.Unlock()
	fake.TasksByCellIDStub = nil
	fake.tasksByCellIDReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TasksByCellIDReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksByCellIDMutex.Lock()
	defer fake.tasksByCellIDMutex.Unlock()
	fake.TasksByCellIDStub = nil
	if fake.tasksByCellIDReturnsOnCall == nil {
		fake.tasksByCellIDReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksByCellIDReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TasksByDomain(arg1 lager.Logger, arg2 string) ([]*models.Task, error) {
	fake.tasksByDomainMutex.Lock()
	ret, specificReturn := fake.tasksByDomainReturnsOnCall[len(fake.tasksByDomainArgsForCall)]
	fake.tasksByDomainArgsForCall = append(fake.tasksByDomainArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("TasksByDomain", []interface{}{arg1, arg2})
	tasksByDomainStubCopy := fake.TasksByDomainStub
	fake.tasksByDomainMutex.Unlock()
	if tasksByDomainStubCopy != nil {
		return tasksByDomainStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tasksByDomainReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) TasksByDomainCallCount() int {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	return len(fake.tasksByDomainArgsForCall)
}

func (fake *FakeClient) TasksByDomainCalls(stub func(lager.Logger, string) ([]*models.Task, error)) {
	fake.tasksByDomainMutex.Lock()
	defer fake.tasksByDomainMutex.Unlock()
	fake.TasksByDomainStub = stub
}

func (fake *FakeClient) TasksByDomainArgsForCall(i int) (lager.Logger, string) {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	argsForCall := fake.tasksByDomainArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TasksByDomainReturns(result1 []*models.Task, result2 error) {
	fake.tasksByDomainMutex.Lock()
	defer fake.tasksByDomainMutex.Unlock()
	fake.TasksByDomainStub = nil
	fake.tasksByDomainReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TasksByDomainReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksByDomainMutex.Lock()
	defer fake.tasksByDomainMutex.Unlock()
	fake.TasksByDomainStub = nil
	if fake.tasksByDomainReturnsOnCall == nil {
		fake.tasksByDomainReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksByDomainReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TasksWithFilter(arg1 lager.Logger, arg2 models.TaskFilter) ([]*models.Task, error) {
	fake.tasksWithFilterMutex.Lock()
	ret, specificReturn := fake.tasksWithFilterReturnsOnCall[len(fake.tasksWithFilterArgsForCall)]
	fake.tasksWithFilterArgsForCall = append(fake.tasksWithFilterArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.TaskFilter
	}{arg1, arg2})
	fake.recordInvocation("TasksWithFilter", []interface{}{arg1, arg2})
	tasksWithFilterStubCopy := fake.TasksWithFilterStub
	fake.tasksWithFilterMutex.Unlock()
	if tasksWithFilterStubCopy != nil {
		return tasksWithFilterStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tasksWithFilterReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) TasksWithFilterCallCount() int {
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	return len(fake.tasksWithFilterArgsForCall)
}

func (fake *FakeClient) TasksWithFilterCalls(stub func(lager.Logger, models.TaskFilter) ([]*models.Task, error)) {
	fake.tasksWithFilterMutex.Lock()
	defer fake.tasksWithFilterMutex.Unlock()
	fake.TasksWithFilterStub = stub
}

func (fake *FakeClient) TasksWithFilterArgsForCall(i int) (lager.Logger, models.TaskFilter) {
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	argsForCall := fake.tasksWithFilterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) TasksWithFilterReturns(result1 []*models.Task, result2 error) {
	fake.tasksWithFilterMutex.Lock()
	defer fake.tasksWithFilterMutex.Unlock()
	fake.TasksWithFilterStub = nil
	fake.tasksWithFilterReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TasksWithFilterReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksWithFilterMutex.Lock()
	defer fake.tasksWithFilterMutex.Unlock()
	fake.TasksWithFilterStub = nil
	if fake.tasksWithFilterReturnsOnCall == nil {
		fake.tasksWithFilterReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksWithFilterReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateDesiredLRP(arg1 lager.Logger, arg2 string, arg3 *models.DesiredLRPUpdate) error {
	fake.updateDesiredLRPMutex.Lock()
	ret, specificReturn := fake.updateDesiredLRPReturnsOnCall[len(fake.updateDesiredLRPArgsForCall)]
	fake.updateDesiredLRPArgsForCall = append(fake.updateDesiredLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.DesiredLRPUpdate
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateDesiredLRP", []interface{}{arg1, arg2, arg3})
	updateDesiredLRPStubCopy := fake.UpdateDesiredLRPStub
	fake.updateDesiredLRPMutex.Unlock()
	if updateDesiredLRPStubCopy != nil {
		return updateDesiredLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateDesiredLRPReturns
	return fakeReturns.result1
}

func (fake *FakeClient) UpdateDesiredLRPCallCount() int {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return len(fake.updateDesiredLRPArgsForCall)
}

func (fake *FakeClient) UpdateDesiredLRPCalls(stub func(lager.Logger, string, *models.DesiredLRPUpdate) error) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = stub
}

func (fake *FakeClient) UpdateDesiredLRPArgsForCall(i int) (lager.Logger, string, *models.DesiredLRPUpdate) {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	argsForCall := fake.updateDesiredLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) UpdateDesiredLRPReturns(result1 error) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = nil
	fake.updateDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpdateDesiredLRPReturnsOnCall(i int, result1 error) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = nil
	if fake.updateDesiredLRPReturnsOnCall == nil {
		fake.updateDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateDesiredLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpsertDomain(arg1 lager.Logger, arg2 string, arg3 time.Duration) error {
	fake.upsertDomainMutex.Lock()
	ret, specificReturn := fake.upsertDomainReturnsOnCall[len(fake.upsertDomainArgsForCall)]
	fake.upsertDomainArgsForCall = append(fake.upsertDomainArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 time.Duration
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpsertDomain", []interface{}{arg1, arg2, arg3})
	upsertDomainStubCopy := fake.UpsertDomainStub
	fake.upsertDomainMutex.Unlock()
	if upsertDomainStubCopy != nil {
		return upsertDomainStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.upsertDomainReturns
	return fakeReturns.result1
}

func (fake *FakeClient) UpsertDomainCallCount() int {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return len(fake.upsertDomainArgsForCall)
}

func (fake *FakeClient) UpsertDomainCalls(stub func(lager.Logger, string, time.Duration) error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = stub
}

func (fake *FakeClient) UpsertDomainArgsForCall(i int) (lager.Logger, string, time.Duration) {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	argsForCall := fake.upsertDomainArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) UpsertDomainReturns(result1 error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = nil
	fake.upsertDomainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpsertDomainReturnsOnCall(i int, result1 error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = nil
	if fake.upsertDomainReturnsOnCall == nil {
		fake.upsertDomainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upsertDomainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	fake.subscribeToInstanceEventsMutex.RLock()
	defer fake.subscribeToInstanceEventsMutex.RUnlock()
	fake.subscribeToInstanceEventsByCellIDMutex.RLock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.RUnlock()
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ bbs.Client = new(FakeClient)
