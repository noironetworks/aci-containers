// Code generated by counterfeiter. DO NOT EDIT.
package helpersfakes

import (
	"context"
	"database/sql"
	"sync"
	"time"

	"code.cloudfoundry.org/bbs/db/sqldb/helpers"
)

type FakeQueryableDB struct {
	BeginTxStub        func(context.Context, *sql.TxOptions) (helpers.Tx, error)
	beginTxMutex       sync.RWMutex
	beginTxArgsForCall []struct {
		arg1 context.Context
		arg2 *sql.TxOptions
	}
	beginTxReturns struct {
		result1 helpers.Tx
		result2 error
	}
	beginTxReturnsOnCall map[int]struct {
		result1 helpers.Tx
		result2 error
	}
	ExecContextStub        func(context.Context, string, ...interface{}) (sql.Result, error)
	execContextMutex       sync.RWMutex
	execContextArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	execContextReturns struct {
		result1 sql.Result
		result2 error
	}
	execContextReturnsOnCall map[int]struct {
		result1 sql.Result
		result2 error
	}
	OpenConnectionsStub        func() int
	openConnectionsMutex       sync.RWMutex
	openConnectionsArgsForCall []struct {
	}
	openConnectionsReturns struct {
		result1 int
	}
	openConnectionsReturnsOnCall map[int]struct {
		result1 int
	}
	PrepareContextStub        func(context.Context, string) (*sql.Stmt, error)
	prepareContextMutex       sync.RWMutex
	prepareContextArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	prepareContextReturns struct {
		result1 *sql.Stmt
		result2 error
	}
	prepareContextReturnsOnCall map[int]struct {
		result1 *sql.Stmt
		result2 error
	}
	QueryContextStub        func(context.Context, string, ...interface{}) (*sql.Rows, error)
	queryContextMutex       sync.RWMutex
	queryContextArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	queryContextReturns struct {
		result1 *sql.Rows
		result2 error
	}
	queryContextReturnsOnCall map[int]struct {
		result1 *sql.Rows
		result2 error
	}
	QueryRowContextStub        func(context.Context, string, ...interface{}) helpers.RowScanner
	queryRowContextMutex       sync.RWMutex
	queryRowContextArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}
	queryRowContextReturns struct {
		result1 helpers.RowScanner
	}
	queryRowContextReturnsOnCall map[int]struct {
		result1 helpers.RowScanner
	}
	WaitCountStub        func() int64
	waitCountMutex       sync.RWMutex
	waitCountArgsForCall []struct {
	}
	waitCountReturns struct {
		result1 int64
	}
	waitCountReturnsOnCall map[int]struct {
		result1 int64
	}
	WaitDurationStub        func() time.Duration
	waitDurationMutex       sync.RWMutex
	waitDurationArgsForCall []struct {
	}
	waitDurationReturns struct {
		result1 time.Duration
	}
	waitDurationReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeQueryableDB) BeginTx(arg1 context.Context, arg2 *sql.TxOptions) (helpers.Tx, error) {
	fake.beginTxMutex.Lock()
	ret, specificReturn := fake.beginTxReturnsOnCall[len(fake.beginTxArgsForCall)]
	fake.beginTxArgsForCall = append(fake.beginTxArgsForCall, struct {
		arg1 context.Context
		arg2 *sql.TxOptions
	}{arg1, arg2})
	fake.recordInvocation("BeginTx", []interface{}{arg1, arg2})
	beginTxStubCopy := fake.BeginTxStub
	fake.beginTxMutex.Unlock()
	if beginTxStubCopy != nil {
		return beginTxStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.beginTxReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueryableDB) BeginTxCallCount() int {
	fake.beginTxMutex.RLock()
	defer fake.beginTxMutex.RUnlock()
	return len(fake.beginTxArgsForCall)
}

func (fake *FakeQueryableDB) BeginTxCalls(stub func(context.Context, *sql.TxOptions) (helpers.Tx, error)) {
	fake.beginTxMutex.Lock()
	defer fake.beginTxMutex.Unlock()
	fake.BeginTxStub = stub
}

func (fake *FakeQueryableDB) BeginTxArgsForCall(i int) (context.Context, *sql.TxOptions) {
	fake.beginTxMutex.RLock()
	defer fake.beginTxMutex.RUnlock()
	argsForCall := fake.beginTxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueryableDB) BeginTxReturns(result1 helpers.Tx, result2 error) {
	fake.beginTxMutex.Lock()
	defer fake.beginTxMutex.Unlock()
	fake.BeginTxStub = nil
	fake.beginTxReturns = struct {
		result1 helpers.Tx
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryableDB) BeginTxReturnsOnCall(i int, result1 helpers.Tx, result2 error) {
	fake.beginTxMutex.Lock()
	defer fake.beginTxMutex.Unlock()
	fake.BeginTxStub = nil
	if fake.beginTxReturnsOnCall == nil {
		fake.beginTxReturnsOnCall = make(map[int]struct {
			result1 helpers.Tx
			result2 error
		})
	}
	fake.beginTxReturnsOnCall[i] = struct {
		result1 helpers.Tx
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryableDB) ExecContext(arg1 context.Context, arg2 string, arg3 ...interface{}) (sql.Result, error) {
	fake.execContextMutex.Lock()
	ret, specificReturn := fake.execContextReturnsOnCall[len(fake.execContextArgsForCall)]
	fake.execContextArgsForCall = append(fake.execContextArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("ExecContext", []interface{}{arg1, arg2, arg3})
	execContextStubCopy := fake.ExecContextStub
	fake.execContextMutex.Unlock()
	if execContextStubCopy != nil {
		return execContextStubCopy(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.execContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueryableDB) ExecContextCallCount() int {
	fake.execContextMutex.RLock()
	defer fake.execContextMutex.RUnlock()
	return len(fake.execContextArgsForCall)
}

func (fake *FakeQueryableDB) ExecContextCalls(stub func(context.Context, string, ...interface{}) (sql.Result, error)) {
	fake.execContextMutex.Lock()
	defer fake.execContextMutex.Unlock()
	fake.ExecContextStub = stub
}

func (fake *FakeQueryableDB) ExecContextArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.execContextMutex.RLock()
	defer fake.execContextMutex.RUnlock()
	argsForCall := fake.execContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeQueryableDB) ExecContextReturns(result1 sql.Result, result2 error) {
	fake.execContextMutex.Lock()
	defer fake.execContextMutex.Unlock()
	fake.ExecContextStub = nil
	fake.execContextReturns = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryableDB) ExecContextReturnsOnCall(i int, result1 sql.Result, result2 error) {
	fake.execContextMutex.Lock()
	defer fake.execContextMutex.Unlock()
	fake.ExecContextStub = nil
	if fake.execContextReturnsOnCall == nil {
		fake.execContextReturnsOnCall = make(map[int]struct {
			result1 sql.Result
			result2 error
		})
	}
	fake.execContextReturnsOnCall[i] = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryableDB) OpenConnections() int {
	fake.openConnectionsMutex.Lock()
	ret, specificReturn := fake.openConnectionsReturnsOnCall[len(fake.openConnectionsArgsForCall)]
	fake.openConnectionsArgsForCall = append(fake.openConnectionsArgsForCall, struct {
	}{})
	fake.recordInvocation("OpenConnections", []interface{}{})
	openConnectionsStubCopy := fake.OpenConnectionsStub
	fake.openConnectionsMutex.Unlock()
	if openConnectionsStubCopy != nil {
		return openConnectionsStubCopy()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.openConnectionsReturns
	return fakeReturns.result1
}

func (fake *FakeQueryableDB) OpenConnectionsCallCount() int {
	fake.openConnectionsMutex.RLock()
	defer fake.openConnectionsMutex.RUnlock()
	return len(fake.openConnectionsArgsForCall)
}

func (fake *FakeQueryableDB) OpenConnectionsCalls(stub func() int) {
	fake.openConnectionsMutex.Lock()
	defer fake.openConnectionsMutex.Unlock()
	fake.OpenConnectionsStub = stub
}

func (fake *FakeQueryableDB) OpenConnectionsReturns(result1 int) {
	fake.openConnectionsMutex.Lock()
	defer fake.openConnectionsMutex.Unlock()
	fake.OpenConnectionsStub = nil
	fake.openConnectionsReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeQueryableDB) OpenConnectionsReturnsOnCall(i int, result1 int) {
	fake.openConnectionsMutex.Lock()
	defer fake.openConnectionsMutex.Unlock()
	fake.OpenConnectionsStub = nil
	if fake.openConnectionsReturnsOnCall == nil {
		fake.openConnectionsReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.openConnectionsReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeQueryableDB) PrepareContext(arg1 context.Context, arg2 string) (*sql.Stmt, error) {
	fake.prepareContextMutex.Lock()
	ret, specificReturn := fake.prepareContextReturnsOnCall[len(fake.prepareContextArgsForCall)]
	fake.prepareContextArgsForCall = append(fake.prepareContextArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("PrepareContext", []interface{}{arg1, arg2})
	prepareContextStubCopy := fake.PrepareContextStub
	fake.prepareContextMutex.Unlock()
	if prepareContextStubCopy != nil {
		return prepareContextStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.prepareContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueryableDB) PrepareContextCallCount() int {
	fake.prepareContextMutex.RLock()
	defer fake.prepareContextMutex.RUnlock()
	return len(fake.prepareContextArgsForCall)
}

func (fake *FakeQueryableDB) PrepareContextCalls(stub func(context.Context, string) (*sql.Stmt, error)) {
	fake.prepareContextMutex.Lock()
	defer fake.prepareContextMutex.Unlock()
	fake.PrepareContextStub = stub
}

func (fake *FakeQueryableDB) PrepareContextArgsForCall(i int) (context.Context, string) {
	fake.prepareContextMutex.RLock()
	defer fake.prepareContextMutex.RUnlock()
	argsForCall := fake.prepareContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueryableDB) PrepareContextReturns(result1 *sql.Stmt, result2 error) {
	fake.prepareContextMutex.Lock()
	defer fake.prepareContextMutex.Unlock()
	fake.PrepareContextStub = nil
	fake.prepareContextReturns = struct {
		result1 *sql.Stmt
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryableDB) PrepareContextReturnsOnCall(i int, result1 *sql.Stmt, result2 error) {
	fake.prepareContextMutex.Lock()
	defer fake.prepareContextMutex.Unlock()
	fake.PrepareContextStub = nil
	if fake.prepareContextReturnsOnCall == nil {
		fake.prepareContextReturnsOnCall = make(map[int]struct {
			result1 *sql.Stmt
			result2 error
		})
	}
	fake.prepareContextReturnsOnCall[i] = struct {
		result1 *sql.Stmt
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryableDB) QueryContext(arg1 context.Context, arg2 string, arg3 ...interface{}) (*sql.Rows, error) {
	fake.queryContextMutex.Lock()
	ret, specificReturn := fake.queryContextReturnsOnCall[len(fake.queryContextArgsForCall)]
	fake.queryContextArgsForCall = append(fake.queryContextArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("QueryContext", []interface{}{arg1, arg2, arg3})
	queryContextStubCopy := fake.QueryContextStub
	fake.queryContextMutex.Unlock()
	if queryContextStubCopy != nil {
		return queryContextStubCopy(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.queryContextReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueryableDB) QueryContextCallCount() int {
	fake.queryContextMutex.RLock()
	defer fake.queryContextMutex.RUnlock()
	return len(fake.queryContextArgsForCall)
}

func (fake *FakeQueryableDB) QueryContextCalls(stub func(context.Context, string, ...interface{}) (*sql.Rows, error)) {
	fake.queryContextMutex.Lock()
	defer fake.queryContextMutex.Unlock()
	fake.QueryContextStub = stub
}

func (fake *FakeQueryableDB) QueryContextArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.queryContextMutex.RLock()
	defer fake.queryContextMutex.RUnlock()
	argsForCall := fake.queryContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeQueryableDB) QueryContextReturns(result1 *sql.Rows, result2 error) {
	fake.queryContextMutex.Lock()
	defer fake.queryContextMutex.Unlock()
	fake.QueryContextStub = nil
	fake.queryContextReturns = struct {
		result1 *sql.Rows
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryableDB) QueryContextReturnsOnCall(i int, result1 *sql.Rows, result2 error) {
	fake.queryContextMutex.Lock()
	defer fake.queryContextMutex.Unlock()
	fake.QueryContextStub = nil
	if fake.queryContextReturnsOnCall == nil {
		fake.queryContextReturnsOnCall = make(map[int]struct {
			result1 *sql.Rows
			result2 error
		})
	}
	fake.queryContextReturnsOnCall[i] = struct {
		result1 *sql.Rows
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryableDB) QueryRowContext(arg1 context.Context, arg2 string, arg3 ...interface{}) helpers.RowScanner {
	fake.queryRowContextMutex.Lock()
	ret, specificReturn := fake.queryRowContextReturnsOnCall[len(fake.queryRowContextArgsForCall)]
	fake.queryRowContextArgsForCall = append(fake.queryRowContextArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("QueryRowContext", []interface{}{arg1, arg2, arg3})
	queryRowContextStubCopy := fake.QueryRowContextStub
	fake.queryRowContextMutex.Unlock()
	if queryRowContextStubCopy != nil {
		return queryRowContextStubCopy(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.queryRowContextReturns
	return fakeReturns.result1
}

func (fake *FakeQueryableDB) QueryRowContextCallCount() int {
	fake.queryRowContextMutex.RLock()
	defer fake.queryRowContextMutex.RUnlock()
	return len(fake.queryRowContextArgsForCall)
}

func (fake *FakeQueryableDB) QueryRowContextCalls(stub func(context.Context, string, ...interface{}) helpers.RowScanner) {
	fake.queryRowContextMutex.Lock()
	defer fake.queryRowContextMutex.Unlock()
	fake.QueryRowContextStub = stub
}

func (fake *FakeQueryableDB) QueryRowContextArgsForCall(i int) (context.Context, string, []interface{}) {
	fake.queryRowContextMutex.RLock()
	defer fake.queryRowContextMutex.RUnlock()
	argsForCall := fake.queryRowContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeQueryableDB) QueryRowContextReturns(result1 helpers.RowScanner) {
	fake.queryRowContextMutex.Lock()
	defer fake.queryRowContextMutex.Unlock()
	fake.QueryRowContextStub = nil
	fake.queryRowContextReturns = struct {
		result1 helpers.RowScanner
	}{result1}
}

func (fake *FakeQueryableDB) QueryRowContextReturnsOnCall(i int, result1 helpers.RowScanner) {
	fake.queryRowContextMutex.Lock()
	defer fake.queryRowContextMutex.Unlock()
	fake.QueryRowContextStub = nil
	if fake.queryRowContextReturnsOnCall == nil {
		fake.queryRowContextReturnsOnCall = make(map[int]struct {
			result1 helpers.RowScanner
		})
	}
	fake.queryRowContextReturnsOnCall[i] = struct {
		result1 helpers.RowScanner
	}{result1}
}

func (fake *FakeQueryableDB) WaitCount() int64 {
	fake.waitCountMutex.Lock()
	ret, specificReturn := fake.waitCountReturnsOnCall[len(fake.waitCountArgsForCall)]
	fake.waitCountArgsForCall = append(fake.waitCountArgsForCall, struct {
	}{})
	fake.recordInvocation("WaitCount", []interface{}{})
	waitCountStubCopy := fake.WaitCountStub
	fake.waitCountMutex.Unlock()
	if waitCountStubCopy != nil {
		return waitCountStubCopy()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.waitCountReturns
	return fakeReturns.result1
}

func (fake *FakeQueryableDB) WaitCountCallCount() int {
	fake.waitCountMutex.RLock()
	defer fake.waitCountMutex.RUnlock()
	return len(fake.waitCountArgsForCall)
}

func (fake *FakeQueryableDB) WaitCountCalls(stub func() int64) {
	fake.waitCountMutex.Lock()
	defer fake.waitCountMutex.Unlock()
	fake.WaitCountStub = stub
}

func (fake *FakeQueryableDB) WaitCountReturns(result1 int64) {
	fake.waitCountMutex.Lock()
	defer fake.waitCountMutex.Unlock()
	fake.WaitCountStub = nil
	fake.waitCountReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeQueryableDB) WaitCountReturnsOnCall(i int, result1 int64) {
	fake.waitCountMutex.Lock()
	defer fake.waitCountMutex.Unlock()
	fake.WaitCountStub = nil
	if fake.waitCountReturnsOnCall == nil {
		fake.waitCountReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.waitCountReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeQueryableDB) WaitDuration() time.Duration {
	fake.waitDurationMutex.Lock()
	ret, specificReturn := fake.waitDurationReturnsOnCall[len(fake.waitDurationArgsForCall)]
	fake.waitDurationArgsForCall = append(fake.waitDurationArgsForCall, struct {
	}{})
	fake.recordInvocation("WaitDuration", []interface{}{})
	waitDurationStubCopy := fake.WaitDurationStub
	fake.waitDurationMutex.Unlock()
	if waitDurationStubCopy != nil {
		return waitDurationStubCopy()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.waitDurationReturns
	return fakeReturns.result1
}

func (fake *FakeQueryableDB) WaitDurationCallCount() int {
	fake.waitDurationMutex.RLock()
	defer fake.waitDurationMutex.RUnlock()
	return len(fake.waitDurationArgsForCall)
}

func (fake *FakeQueryableDB) WaitDurationCalls(stub func() time.Duration) {
	fake.waitDurationMutex.Lock()
	defer fake.waitDurationMutex.Unlock()
	fake.WaitDurationStub = stub
}

func (fake *FakeQueryableDB) WaitDurationReturns(result1 time.Duration) {
	fake.waitDurationMutex.Lock()
	defer fake.waitDurationMutex.Unlock()
	fake.WaitDurationStub = nil
	fake.waitDurationReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeQueryableDB) WaitDurationReturnsOnCall(i int, result1 time.Duration) {
	fake.waitDurationMutex.Lock()
	defer fake.waitDurationMutex.Unlock()
	fake.WaitDurationStub = nil
	if fake.waitDurationReturnsOnCall == nil {
		fake.waitDurationReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.waitDurationReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeQueryableDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.beginTxMutex.RLock()
	defer fake.beginTxMutex.RUnlock()
	fake.execContextMutex.RLock()
	defer fake.execContextMutex.RUnlock()
	fake.openConnectionsMutex.RLock()
	defer fake.openConnectionsMutex.RUnlock()
	fake.prepareContextMutex.RLock()
	defer fake.prepareContextMutex.RUnlock()
	fake.queryContextMutex.RLock()
	defer fake.queryContextMutex.RUnlock()
	fake.queryRowContextMutex.RLock()
	defer fake.queryRowContextMutex.RUnlock()
	fake.waitCountMutex.RLock()
	defer fake.waitCountMutex.RUnlock()
	fake.waitDurationMutex.RLock()
	defer fake.waitDurationMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeQueryableDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ helpers.QueryableDB = new(FakeQueryableDB)
