// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"context"
	"sync"
	"time"

	"code.cloudfoundry.org/bbs/db"
	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/lager"
)

type FakeDB struct {
	ActualLRPsStub        func(context.Context, lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRP, error)
	actualLRPsMutex       sync.RWMutex
	actualLRPsArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.ActualLRPFilter
	}
	actualLRPsReturns struct {
		result1 []*models.ActualLRP
		result2 error
	}
	actualLRPsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRP
		result2 error
	}
	CancelTaskStub        func(context.Context, lager.Logger, string) (*models.Task, *models.Task, string, error)
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}
	cancelTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 string
		result4 error
	}
	cancelTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 string
		result4 error
	}
	ChangeActualLRPPresenceStub        func(context.Context, lager.Logger, *models.ActualLRPKey, models.ActualLRP_Presence, models.ActualLRP_Presence) (*models.ActualLRP, *models.ActualLRP, error)
	changeActualLRPPresenceMutex       sync.RWMutex
	changeActualLRPPresenceArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 models.ActualLRP_Presence
		arg5 models.ActualLRP_Presence
	}
	changeActualLRPPresenceReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	changeActualLRPPresenceReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	ClaimActualLRPStub        func(context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) (*models.ActualLRP, *models.ActualLRP, error)
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 int32
		arg5 *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	claimActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	CompleteTaskStub        func(context.Context, lager.Logger, string, string, bool, string, string) (*models.Task, *models.Task, error)
	completeTaskMutex       sync.RWMutex
	completeTaskArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 string
		arg5 bool
		arg6 string
		arg7 string
	}
	completeTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	completeTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	ConvergeLRPsStub        func(context.Context, lager.Logger, models.CellSet) db.ConvergenceResult
	convergeLRPsMutex       sync.RWMutex
	convergeLRPsArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.CellSet
	}
	convergeLRPsReturns struct {
		result1 db.ConvergenceResult
	}
	convergeLRPsReturnsOnCall map[int]struct {
		result1 db.ConvergenceResult
	}
	ConvergeTasksStub        func(context.Context, lager.Logger, models.CellSet, time.Duration, time.Duration, time.Duration) db.TaskConvergenceResult
	convergeTasksMutex       sync.RWMutex
	convergeTasksArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.CellSet
		arg4 time.Duration
		arg5 time.Duration
		arg6 time.Duration
	}
	convergeTasksReturns struct {
		result1 db.TaskConvergenceResult
	}
	convergeTasksReturnsOnCall map[int]struct {
		result1 db.TaskConvergenceResult
	}
	CountActualLRPsByStateStub        func(context.Context, lager.Logger) (int, int, int, int, int)
	countActualLRPsByStateMutex       sync.RWMutex
	countActualLRPsByStateArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
	}
	countActualLRPsByStateReturns struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}
	countActualLRPsByStateReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}
	CountDesiredInstancesStub        func(context.Context, lager.Logger) int
	countDesiredInstancesMutex       sync.RWMutex
	countDesiredInstancesArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
	}
	countDesiredInstancesReturns struct {
		result1 int
	}
	countDesiredInstancesReturnsOnCall map[int]struct {
		result1 int
	}
	CrashActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) (*models.ActualLRP, *models.ActualLRP, bool, error)
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 string
	}
	crashActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}
	crashActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}
	CreateUnclaimedActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey) (*models.ActualLRP, error)
	createUnclaimedActualLRPMutex       sync.RWMutex
	createUnclaimedActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
	}
	createUnclaimedActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 error
	}
	createUnclaimedActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 error
	}
	DeleteTaskStub        func(context.Context, lager.Logger, string) (*models.Task, error)
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}
	deleteTaskReturns struct {
		result1 *models.Task
		result2 error
	}
	deleteTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 error
	}
	DesireLRPStub        func(context.Context, lager.Logger, *models.DesiredLRP) error
	desireLRPMutex       sync.RWMutex
	desireLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.DesiredLRP
	}
	desireLRPReturns struct {
		result1 error
	}
	desireLRPReturnsOnCall map[int]struct {
		result1 error
	}
	DesireTaskStub        func(context.Context, lager.Logger, *models.TaskDefinition, string, string) (*models.Task, error)
	desireTaskMutex       sync.RWMutex
	desireTaskArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.TaskDefinition
		arg4 string
		arg5 string
	}
	desireTaskReturns struct {
		result1 *models.Task
		result2 error
	}
	desireTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 error
	}
	DesiredLRPByProcessGuidStub        func(context.Context, lager.Logger, string) (*models.DesiredLRP, error)
	desiredLRPByProcessGuidMutex       sync.RWMutex
	desiredLRPByProcessGuidArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}
	desiredLRPByProcessGuidReturns struct {
		result1 *models.DesiredLRP
		result2 error
	}
	desiredLRPByProcessGuidReturnsOnCall map[int]struct {
		result1 *models.DesiredLRP
		result2 error
	}
	DesiredLRPSchedulingInfosStub        func(context.Context, lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)
	desiredLRPSchedulingInfosMutex       sync.RWMutex
	desiredLRPSchedulingInfosArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.DesiredLRPFilter
	}
	desiredLRPSchedulingInfosReturns struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	desiredLRPSchedulingInfosReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	DesiredLRPsStub        func(context.Context, lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)
	desiredLRPsMutex       sync.RWMutex
	desiredLRPsArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.DesiredLRPFilter
	}
	desiredLRPsReturns struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	desiredLRPsReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	EncryptionKeyLabelStub        func(context.Context, lager.Logger) (string, error)
	encryptionKeyLabelMutex       sync.RWMutex
	encryptionKeyLabelArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
	}
	encryptionKeyLabelReturns struct {
		result1 string
		result2 error
	}
	encryptionKeyLabelReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	EvacuateActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) (*models.ActualLRP, error)
	evacuateActualLRPMutex       sync.RWMutex
	evacuateActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 *models.ActualLRPNetInfo
	}
	evacuateActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 error
	}
	evacuateActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 error
	}
	FailActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey, string) (*models.ActualLRP, *models.ActualLRP, error)
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 string
	}
	failActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	failActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	FailTaskStub        func(context.Context, lager.Logger, string, string) (*models.Task, *models.Task, error)
	failTaskMutex       sync.RWMutex
	failTaskArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 string
	}
	failTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	failTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	FreshDomainsStub        func(context.Context, lager.Logger) ([]string, error)
	freshDomainsMutex       sync.RWMutex
	freshDomainsArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
	}
	freshDomainsReturns struct {
		result1 []string
		result2 error
	}
	freshDomainsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	PerformEncryptionStub        func(context.Context, lager.Logger) error
	performEncryptionMutex       sync.RWMutex
	performEncryptionArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
	}
	performEncryptionReturns struct {
		result1 error
	}
	performEncryptionReturnsOnCall map[int]struct {
		result1 error
	}
	RejectTaskStub        func(context.Context, lager.Logger, string, string) (*models.Task, *models.Task, error)
	rejectTaskMutex       sync.RWMutex
	rejectTaskArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 string
	}
	rejectTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	rejectTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	RemoveActualLRPStub        func(context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 int32
		arg5 *models.ActualLRPInstanceKey
	}
	removeActualLRPReturns struct {
		result1 error
	}
	removeActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveDesiredLRPStub        func(context.Context, lager.Logger, string) error
	removeDesiredLRPMutex       sync.RWMutex
	removeDesiredLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}
	removeDesiredLRPReturns struct {
		result1 error
	}
	removeDesiredLRPReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveEvacuatingActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error
	removeEvacuatingActualLRPMutex       sync.RWMutex
	removeEvacuatingActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}
	removeEvacuatingActualLRPReturns struct {
		result1 error
	}
	removeEvacuatingActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveSuspectActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey) (*models.ActualLRP, error)
	removeSuspectActualLRPMutex       sync.RWMutex
	removeSuspectActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
	}
	removeSuspectActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 error
	}
	removeSuspectActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 error
	}
	ResolvingTaskStub        func(context.Context, lager.Logger, string) (*models.Task, *models.Task, error)
	resolvingTaskMutex       sync.RWMutex
	resolvingTaskArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}
	resolvingTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	resolvingTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}
	SetEncryptionKeyLabelStub        func(context.Context, lager.Logger, string) error
	setEncryptionKeyLabelMutex       sync.RWMutex
	setEncryptionKeyLabelArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}
	setEncryptionKeyLabelReturns struct {
		result1 error
	}
	setEncryptionKeyLabelReturnsOnCall map[int]struct {
		result1 error
	}
	SetVersionStub        func(context.Context, lager.Logger, *models.Version) error
	setVersionMutex       sync.RWMutex
	setVersionArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.Version
	}
	setVersionReturns struct {
		result1 error
	}
	setVersionReturnsOnCall map[int]struct {
		result1 error
	}
	StartActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) (*models.ActualLRP, *models.ActualLRP, error)
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 *models.ActualLRPNetInfo
	}
	startActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	startActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	StartTaskStub        func(context.Context, lager.Logger, string, string) (*models.Task, *models.Task, bool, error)
	startTaskMutex       sync.RWMutex
	startTaskArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 string
	}
	startTaskReturns struct {
		result1 *models.Task
		result2 *models.Task
		result3 bool
		result4 error
	}
	startTaskReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 *models.Task
		result3 bool
		result4 error
	}
	TaskByGuidStub        func(context.Context, lager.Logger, string) (*models.Task, error)
	taskByGuidMutex       sync.RWMutex
	taskByGuidArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}
	taskByGuidReturns struct {
		result1 *models.Task
		result2 error
	}
	taskByGuidReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 error
	}
	TasksStub        func(context.Context, lager.Logger, models.TaskFilter) ([]*models.Task, error)
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.TaskFilter
	}
	tasksReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	UnclaimActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey) (*models.ActualLRP, *models.ActualLRP, error)
	unclaimActualLRPMutex       sync.RWMutex
	unclaimActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
	}
	unclaimActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	unclaimActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	UpdateDesiredLRPStub        func(context.Context, lager.Logger, string, *models.DesiredLRPUpdate) (*models.DesiredLRP, error)
	updateDesiredLRPMutex       sync.RWMutex
	updateDesiredLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 *models.DesiredLRPUpdate
	}
	updateDesiredLRPReturns struct {
		result1 *models.DesiredLRP
		result2 error
	}
	updateDesiredLRPReturnsOnCall map[int]struct {
		result1 *models.DesiredLRP
		result2 error
	}
	UpsertDomainStub        func(context.Context, lager.Logger, string, uint32) error
	upsertDomainMutex       sync.RWMutex
	upsertDomainArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 uint32
	}
	upsertDomainReturns struct {
		result1 error
	}
	upsertDomainReturnsOnCall map[int]struct {
		result1 error
	}
	VersionStub        func(context.Context, lager.Logger) (*models.Version, error)
	versionMutex       sync.RWMutex
	versionArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
	}
	versionReturns struct {
		result1 *models.Version
		result2 error
	}
	versionReturnsOnCall map[int]struct {
		result1 *models.Version
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDB) ActualLRPs(arg1 context.Context, arg2 lager.Logger, arg3 models.ActualLRPFilter) ([]*models.ActualLRP, error) {
	fake.actualLRPsMutex.Lock()
	ret, specificReturn := fake.actualLRPsReturnsOnCall[len(fake.actualLRPsArgsForCall)]
	fake.actualLRPsArgsForCall = append(fake.actualLRPsArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.ActualLRPFilter
	}{arg1, arg2, arg3})
	fake.recordInvocation("ActualLRPs", []interface{}{arg1, arg2, arg3})
	actualLRPsStubCopy := fake.ActualLRPsStub
	fake.actualLRPsMutex.Unlock()
	if actualLRPsStubCopy != nil {
		return actualLRPsStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.actualLRPsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) ActualLRPsCallCount() int {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	return len(fake.actualLRPsArgsForCall)
}

func (fake *FakeDB) ActualLRPsCalls(stub func(context.Context, lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRP, error)) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = stub
}

func (fake *FakeDB) ActualLRPsArgsForCall(i int) (context.Context, lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	argsForCall := fake.actualLRPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) ActualLRPsReturns(result1 []*models.ActualLRP, result2 error) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = nil
	fake.actualLRPsReturns = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ActualLRPsReturnsOnCall(i int, result1 []*models.ActualLRP, result2 error) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = nil
	if fake.actualLRPsReturnsOnCall == nil {
		fake.actualLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRP
			result2 error
		})
	}
	fake.actualLRPsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) CancelTask(arg1 context.Context, arg2 lager.Logger, arg3 string) (*models.Task, *models.Task, string, error) {
	fake.cancelTaskMutex.Lock()
	ret, specificReturn := fake.cancelTaskReturnsOnCall[len(fake.cancelTaskArgsForCall)]
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("CancelTask", []interface{}{arg1, arg2, arg3})
	cancelTaskStubCopy := fake.CancelTaskStub
	fake.cancelTaskMutex.Unlock()
	if cancelTaskStubCopy != nil {
		return cancelTaskStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.cancelTaskReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeDB) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeDB) CancelTaskCalls(stub func(context.Context, lager.Logger, string) (*models.Task, *models.Task, string, error)) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = stub
}

func (fake *FakeDB) CancelTaskArgsForCall(i int) (context.Context, lager.Logger, string) {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	argsForCall := fake.cancelTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) CancelTaskReturns(result1 *models.Task, result2 *models.Task, result3 string, result4 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 string
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) CancelTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 string, result4 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	if fake.cancelTaskReturnsOnCall == nil {
		fake.cancelTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 string
			result4 error
		})
	}
	fake.cancelTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 string
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) ChangeActualLRPPresence(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey, arg4 models.ActualLRP_Presence, arg5 models.ActualLRP_Presence) (*models.ActualLRP, *models.ActualLRP, error) {
	fake.changeActualLRPPresenceMutex.Lock()
	ret, specificReturn := fake.changeActualLRPPresenceReturnsOnCall[len(fake.changeActualLRPPresenceArgsForCall)]
	fake.changeActualLRPPresenceArgsForCall = append(fake.changeActualLRPPresenceArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 models.ActualLRP_Presence
		arg5 models.ActualLRP_Presence
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("ChangeActualLRPPresence", []interface{}{arg1, arg2, arg3, arg4, arg5})
	changeActualLRPPresenceStubCopy := fake.ChangeActualLRPPresenceStub
	fake.changeActualLRPPresenceMutex.Unlock()
	if changeActualLRPPresenceStubCopy != nil {
		return changeActualLRPPresenceStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.changeActualLRPPresenceReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDB) ChangeActualLRPPresenceCallCount() int {
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	return len(fake.changeActualLRPPresenceArgsForCall)
}

func (fake *FakeDB) ChangeActualLRPPresenceCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey, models.ActualLRP_Presence, models.ActualLRP_Presence) (*models.ActualLRP, *models.ActualLRP, error)) {
	fake.changeActualLRPPresenceMutex.Lock()
	defer fake.changeActualLRPPresenceMutex.Unlock()
	fake.ChangeActualLRPPresenceStub = stub
}

func (fake *FakeDB) ChangeActualLRPPresenceArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey, models.ActualLRP_Presence, models.ActualLRP_Presence) {
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	argsForCall := fake.changeActualLRPPresenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeDB) ChangeActualLRPPresenceReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.changeActualLRPPresenceMutex.Lock()
	defer fake.changeActualLRPPresenceMutex.Unlock()
	fake.ChangeActualLRPPresenceStub = nil
	fake.changeActualLRPPresenceReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) ChangeActualLRPPresenceReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.changeActualLRPPresenceMutex.Lock()
	defer fake.changeActualLRPPresenceMutex.Unlock()
	fake.ChangeActualLRPPresenceStub = nil
	if fake.changeActualLRPPresenceReturnsOnCall == nil {
		fake.changeActualLRPPresenceReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.changeActualLRPPresenceReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) ClaimActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 string, arg4 int32, arg5 *models.ActualLRPInstanceKey) (*models.ActualLRP, *models.ActualLRP, error) {
	fake.claimActualLRPMutex.Lock()
	ret, specificReturn := fake.claimActualLRPReturnsOnCall[len(fake.claimActualLRPArgsForCall)]
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 int32
		arg5 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("ClaimActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	claimActualLRPStubCopy := fake.ClaimActualLRPStub
	fake.claimActualLRPMutex.Unlock()
	if claimActualLRPStubCopy != nil {
		return claimActualLRPStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.claimActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDB) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeDB) ClaimActualLRPCalls(stub func(context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) (*models.ActualLRP, *models.ActualLRP, error)) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = stub
}

func (fake *FakeDB) ClaimActualLRPArgsForCall(i int) (context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	argsForCall := fake.claimActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeDB) ClaimActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) ClaimActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = nil
	if fake.claimActualLRPReturnsOnCall == nil {
		fake.claimActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.claimActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) CompleteTask(arg1 context.Context, arg2 lager.Logger, arg3 string, arg4 string, arg5 bool, arg6 string, arg7 string) (*models.Task, *models.Task, error) {
	fake.completeTaskMutex.Lock()
	ret, specificReturn := fake.completeTaskReturnsOnCall[len(fake.completeTaskArgsForCall)]
	fake.completeTaskArgsForCall = append(fake.completeTaskArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 string
		arg5 bool
		arg6 string
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.recordInvocation("CompleteTask", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	completeTaskStubCopy := fake.CompleteTaskStub
	fake.completeTaskMutex.Unlock()
	if completeTaskStubCopy != nil {
		return completeTaskStubCopy(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.completeTaskReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDB) CompleteTaskCallCount() int {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return len(fake.completeTaskArgsForCall)
}

func (fake *FakeDB) CompleteTaskCalls(stub func(context.Context, lager.Logger, string, string, bool, string, string) (*models.Task, *models.Task, error)) {
	fake.completeTaskMutex.Lock()
	defer fake.completeTaskMutex.Unlock()
	fake.CompleteTaskStub = stub
}

func (fake *FakeDB) CompleteTaskArgsForCall(i int) (context.Context, lager.Logger, string, string, bool, string, string) {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	argsForCall := fake.completeTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeDB) CompleteTaskReturns(result1 *models.Task, result2 *models.Task, result3 error) {
	fake.completeTaskMutex.Lock()
	defer fake.completeTaskMutex.Unlock()
	fake.CompleteTaskStub = nil
	fake.completeTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) CompleteTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 error) {
	fake.completeTaskMutex.Lock()
	defer fake.completeTaskMutex.Unlock()
	fake.CompleteTaskStub = nil
	if fake.completeTaskReturnsOnCall == nil {
		fake.completeTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 error
		})
	}
	fake.completeTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) ConvergeLRPs(arg1 context.Context, arg2 lager.Logger, arg3 models.CellSet) db.ConvergenceResult {
	fake.convergeLRPsMutex.Lock()
	ret, specificReturn := fake.convergeLRPsReturnsOnCall[len(fake.convergeLRPsArgsForCall)]
	fake.convergeLRPsArgsForCall = append(fake.convergeLRPsArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.CellSet
	}{arg1, arg2, arg3})
	fake.recordInvocation("ConvergeLRPs", []interface{}{arg1, arg2, arg3})
	convergeLRPsStubCopy := fake.ConvergeLRPsStub
	fake.convergeLRPsMutex.Unlock()
	if convergeLRPsStubCopy != nil {
		return convergeLRPsStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.convergeLRPsReturns
	return fakeReturns.result1
}

func (fake *FakeDB) ConvergeLRPsCallCount() int {
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	return len(fake.convergeLRPsArgsForCall)
}

func (fake *FakeDB) ConvergeLRPsCalls(stub func(context.Context, lager.Logger, models.CellSet) db.ConvergenceResult) {
	fake.convergeLRPsMutex.Lock()
	defer fake.convergeLRPsMutex.Unlock()
	fake.ConvergeLRPsStub = stub
}

func (fake *FakeDB) ConvergeLRPsArgsForCall(i int) (context.Context, lager.Logger, models.CellSet) {
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	argsForCall := fake.convergeLRPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) ConvergeLRPsReturns(result1 db.ConvergenceResult) {
	fake.convergeLRPsMutex.Lock()
	defer fake.convergeLRPsMutex.Unlock()
	fake.ConvergeLRPsStub = nil
	fake.convergeLRPsReturns = struct {
		result1 db.ConvergenceResult
	}{result1}
}

func (fake *FakeDB) ConvergeLRPsReturnsOnCall(i int, result1 db.ConvergenceResult) {
	fake.convergeLRPsMutex.Lock()
	defer fake.convergeLRPsMutex.Unlock()
	fake.ConvergeLRPsStub = nil
	if fake.convergeLRPsReturnsOnCall == nil {
		fake.convergeLRPsReturnsOnCall = make(map[int]struct {
			result1 db.ConvergenceResult
		})
	}
	fake.convergeLRPsReturnsOnCall[i] = struct {
		result1 db.ConvergenceResult
	}{result1}
}

func (fake *FakeDB) ConvergeTasks(arg1 context.Context, arg2 lager.Logger, arg3 models.CellSet, arg4 time.Duration, arg5 time.Duration, arg6 time.Duration) db.TaskConvergenceResult {
	fake.convergeTasksMutex.Lock()
	ret, specificReturn := fake.convergeTasksReturnsOnCall[len(fake.convergeTasksArgsForCall)]
	fake.convergeTasksArgsForCall = append(fake.convergeTasksArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.CellSet
		arg4 time.Duration
		arg5 time.Duration
		arg6 time.Duration
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.recordInvocation("ConvergeTasks", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	convergeTasksStubCopy := fake.ConvergeTasksStub
	fake.convergeTasksMutex.Unlock()
	if convergeTasksStubCopy != nil {
		return convergeTasksStubCopy(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.convergeTasksReturns
	return fakeReturns.result1
}

func (fake *FakeDB) ConvergeTasksCallCount() int {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return len(fake.convergeTasksArgsForCall)
}

func (fake *FakeDB) ConvergeTasksCalls(stub func(context.Context, lager.Logger, models.CellSet, time.Duration, time.Duration, time.Duration) db.TaskConvergenceResult) {
	fake.convergeTasksMutex.Lock()
	defer fake.convergeTasksMutex.Unlock()
	fake.ConvergeTasksStub = stub
}

func (fake *FakeDB) ConvergeTasksArgsForCall(i int) (context.Context, lager.Logger, models.CellSet, time.Duration, time.Duration, time.Duration) {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	argsForCall := fake.convergeTasksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeDB) ConvergeTasksReturns(result1 db.TaskConvergenceResult) {
	fake.convergeTasksMutex.Lock()
	defer fake.convergeTasksMutex.Unlock()
	fake.ConvergeTasksStub = nil
	fake.convergeTasksReturns = struct {
		result1 db.TaskConvergenceResult
	}{result1}
}

func (fake *FakeDB) ConvergeTasksReturnsOnCall(i int, result1 db.TaskConvergenceResult) {
	fake.convergeTasksMutex.Lock()
	defer fake.convergeTasksMutex.Unlock()
	fake.ConvergeTasksStub = nil
	if fake.convergeTasksReturnsOnCall == nil {
		fake.convergeTasksReturnsOnCall = make(map[int]struct {
			result1 db.TaskConvergenceResult
		})
	}
	fake.convergeTasksReturnsOnCall[i] = struct {
		result1 db.TaskConvergenceResult
	}{result1}
}

func (fake *FakeDB) CountActualLRPsByState(arg1 context.Context, arg2 lager.Logger) (int, int, int, int, int) {
	fake.countActualLRPsByStateMutex.Lock()
	ret, specificReturn := fake.countActualLRPsByStateReturnsOnCall[len(fake.countActualLRPsByStateArgsForCall)]
	fake.countActualLRPsByStateArgsForCall = append(fake.countActualLRPsByStateArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
	}{arg1, arg2})
	fake.recordInvocation("CountActualLRPsByState", []interface{}{arg1, arg2})
	countActualLRPsByStateStubCopy := fake.CountActualLRPsByStateStub
	fake.countActualLRPsByStateMutex.Unlock()
	if countActualLRPsByStateStubCopy != nil {
		return countActualLRPsByStateStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4, ret.result5
	}
	fakeReturns := fake.countActualLRPsByStateReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4, fakeReturns.result5
}

func (fake *FakeDB) CountActualLRPsByStateCallCount() int {
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	return len(fake.countActualLRPsByStateArgsForCall)
}

func (fake *FakeDB) CountActualLRPsByStateCalls(stub func(context.Context, lager.Logger) (int, int, int, int, int)) {
	fake.countActualLRPsByStateMutex.Lock()
	defer fake.countActualLRPsByStateMutex.Unlock()
	fake.CountActualLRPsByStateStub = stub
}

func (fake *FakeDB) CountActualLRPsByStateArgsForCall(i int) (context.Context, lager.Logger) {
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	argsForCall := fake.countActualLRPsByStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDB) CountActualLRPsByStateReturns(result1 int, result2 int, result3 int, result4 int, result5 int) {
	fake.countActualLRPsByStateMutex.Lock()
	defer fake.countActualLRPsByStateMutex.Unlock()
	fake.CountActualLRPsByStateStub = nil
	fake.countActualLRPsByStateReturns = struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeDB) CountActualLRPsByStateReturnsOnCall(i int, result1 int, result2 int, result3 int, result4 int, result5 int) {
	fake.countActualLRPsByStateMutex.Lock()
	defer fake.countActualLRPsByStateMutex.Unlock()
	fake.CountActualLRPsByStateStub = nil
	if fake.countActualLRPsByStateReturnsOnCall == nil {
		fake.countActualLRPsByStateReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 int
			result4 int
			result5 int
		})
	}
	fake.countActualLRPsByStateReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeDB) CountDesiredInstances(arg1 context.Context, arg2 lager.Logger) int {
	fake.countDesiredInstancesMutex.Lock()
	ret, specificReturn := fake.countDesiredInstancesReturnsOnCall[len(fake.countDesiredInstancesArgsForCall)]
	fake.countDesiredInstancesArgsForCall = append(fake.countDesiredInstancesArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
	}{arg1, arg2})
	fake.recordInvocation("CountDesiredInstances", []interface{}{arg1, arg2})
	countDesiredInstancesStubCopy := fake.CountDesiredInstancesStub
	fake.countDesiredInstancesMutex.Unlock()
	if countDesiredInstancesStubCopy != nil {
		return countDesiredInstancesStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.countDesiredInstancesReturns
	return fakeReturns.result1
}

func (fake *FakeDB) CountDesiredInstancesCallCount() int {
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	return len(fake.countDesiredInstancesArgsForCall)
}

func (fake *FakeDB) CountDesiredInstancesCalls(stub func(context.Context, lager.Logger) int) {
	fake.countDesiredInstancesMutex.Lock()
	defer fake.countDesiredInstancesMutex.Unlock()
	fake.CountDesiredInstancesStub = stub
}

func (fake *FakeDB) CountDesiredInstancesArgsForCall(i int) (context.Context, lager.Logger) {
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	argsForCall := fake.countDesiredInstancesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDB) CountDesiredInstancesReturns(result1 int) {
	fake.countDesiredInstancesMutex.Lock()
	defer fake.countDesiredInstancesMutex.Unlock()
	fake.CountDesiredInstancesStub = nil
	fake.countDesiredInstancesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeDB) CountDesiredInstancesReturnsOnCall(i int, result1 int) {
	fake.countDesiredInstancesMutex.Lock()
	defer fake.countDesiredInstancesMutex.Unlock()
	fake.CountDesiredInstancesStub = nil
	if fake.countDesiredInstancesReturnsOnCall == nil {
		fake.countDesiredInstancesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.countDesiredInstancesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeDB) CrashActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey, arg5 string) (*models.ActualLRP, *models.ActualLRP, bool, error) {
	fake.crashActualLRPMutex.Lock()
	ret, specificReturn := fake.crashActualLRPReturnsOnCall[len(fake.crashActualLRPArgsForCall)]
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("CrashActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	crashActualLRPStubCopy := fake.CrashActualLRPStub
	fake.crashActualLRPMutex.Unlock()
	if crashActualLRPStubCopy != nil {
		return crashActualLRPStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.crashActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeDB) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeDB) CrashActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) (*models.ActualLRP, *models.ActualLRP, bool, error)) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = stub
}

func (fake *FakeDB) CrashActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	argsForCall := fake.crashActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeDB) CrashActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 bool, result4 error) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) CrashActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 bool, result4 error) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = nil
	if fake.crashActualLRPReturnsOnCall == nil {
		fake.crashActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 bool
			result4 error
		})
	}
	fake.crashActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) CreateUnclaimedActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey) (*models.ActualLRP, error) {
	fake.createUnclaimedActualLRPMutex.Lock()
	ret, specificReturn := fake.createUnclaimedActualLRPReturnsOnCall[len(fake.createUnclaimedActualLRPArgsForCall)]
	fake.createUnclaimedActualLRPArgsForCall = append(fake.createUnclaimedActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("CreateUnclaimedActualLRP", []interface{}{arg1, arg2, arg3})
	createUnclaimedActualLRPStubCopy := fake.CreateUnclaimedActualLRPStub
	fake.createUnclaimedActualLRPMutex.Unlock()
	if createUnclaimedActualLRPStubCopy != nil {
		return createUnclaimedActualLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createUnclaimedActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) CreateUnclaimedActualLRPCallCount() int {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	return len(fake.createUnclaimedActualLRPArgsForCall)
}

func (fake *FakeDB) CreateUnclaimedActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey) (*models.ActualLRP, error)) {
	fake.createUnclaimedActualLRPMutex.Lock()
	defer fake.createUnclaimedActualLRPMutex.Unlock()
	fake.CreateUnclaimedActualLRPStub = stub
}

func (fake *FakeDB) CreateUnclaimedActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey) {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	argsForCall := fake.createUnclaimedActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) CreateUnclaimedActualLRPReturns(result1 *models.ActualLRP, result2 error) {
	fake.createUnclaimedActualLRPMutex.Lock()
	defer fake.createUnclaimedActualLRPMutex.Unlock()
	fake.CreateUnclaimedActualLRPStub = nil
	fake.createUnclaimedActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) CreateUnclaimedActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 error) {
	fake.createUnclaimedActualLRPMutex.Lock()
	defer fake.createUnclaimedActualLRPMutex.Unlock()
	fake.CreateUnclaimedActualLRPStub = nil
	if fake.createUnclaimedActualLRPReturnsOnCall == nil {
		fake.createUnclaimedActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 error
		})
	}
	fake.createUnclaimedActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DeleteTask(arg1 context.Context, arg2 lager.Logger, arg3 string) (*models.Task, error) {
	fake.deleteTaskMutex.Lock()
	ret, specificReturn := fake.deleteTaskReturnsOnCall[len(fake.deleteTaskArgsForCall)]
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("DeleteTask", []interface{}{arg1, arg2, arg3})
	deleteTaskStubCopy := fake.DeleteTaskStub
	fake.deleteTaskMutex.Unlock()
	if deleteTaskStubCopy != nil {
		return deleteTaskStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteTaskReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeDB) DeleteTaskCalls(stub func(context.Context, lager.Logger, string) (*models.Task, error)) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = stub
}

func (fake *FakeDB) DeleteTaskArgsForCall(i int) (context.Context, lager.Logger, string) {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	argsForCall := fake.deleteTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) DeleteTaskReturns(result1 *models.Task, result2 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DeleteTaskReturnsOnCall(i int, result1 *models.Task, result2 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	if fake.deleteTaskReturnsOnCall == nil {
		fake.deleteTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 error
		})
	}
	fake.deleteTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesireLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.DesiredLRP) error {
	fake.desireLRPMutex.Lock()
	ret, specificReturn := fake.desireLRPReturnsOnCall[len(fake.desireLRPArgsForCall)]
	fake.desireLRPArgsForCall = append(fake.desireLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.DesiredLRP
	}{arg1, arg2, arg3})
	fake.recordInvocation("DesireLRP", []interface{}{arg1, arg2, arg3})
	desireLRPStubCopy := fake.DesireLRPStub
	fake.desireLRPMutex.Unlock()
	if desireLRPStubCopy != nil {
		return desireLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.desireLRPReturns
	return fakeReturns.result1
}

func (fake *FakeDB) DesireLRPCallCount() int {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return len(fake.desireLRPArgsForCall)
}

func (fake *FakeDB) DesireLRPCalls(stub func(context.Context, lager.Logger, *models.DesiredLRP) error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = stub
}

func (fake *FakeDB) DesireLRPArgsForCall(i int) (context.Context, lager.Logger, *models.DesiredLRP) {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	argsForCall := fake.desireLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) DesireLRPReturns(result1 error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = nil
	fake.desireLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) DesireLRPReturnsOnCall(i int, result1 error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = nil
	if fake.desireLRPReturnsOnCall == nil {
		fake.desireLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.desireLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) DesireTask(arg1 context.Context, arg2 lager.Logger, arg3 *models.TaskDefinition, arg4 string, arg5 string) (*models.Task, error) {
	fake.desireTaskMutex.Lock()
	ret, specificReturn := fake.desireTaskReturnsOnCall[len(fake.desireTaskArgsForCall)]
	fake.desireTaskArgsForCall = append(fake.desireTaskArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.TaskDefinition
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("DesireTask", []interface{}{arg1, arg2, arg3, arg4, arg5})
	desireTaskStubCopy := fake.DesireTaskStub
	fake.desireTaskMutex.Unlock()
	if desireTaskStubCopy != nil {
		return desireTaskStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.desireTaskReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) DesireTaskCallCount() int {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return len(fake.desireTaskArgsForCall)
}

func (fake *FakeDB) DesireTaskCalls(stub func(context.Context, lager.Logger, *models.TaskDefinition, string, string) (*models.Task, error)) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = stub
}

func (fake *FakeDB) DesireTaskArgsForCall(i int) (context.Context, lager.Logger, *models.TaskDefinition, string, string) {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	argsForCall := fake.desireTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeDB) DesireTaskReturns(result1 *models.Task, result2 error) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = nil
	fake.desireTaskReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesireTaskReturnsOnCall(i int, result1 *models.Task, result2 error) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = nil
	if fake.desireTaskReturnsOnCall == nil {
		fake.desireTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 error
		})
	}
	fake.desireTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPByProcessGuid(arg1 context.Context, arg2 lager.Logger, arg3 string) (*models.DesiredLRP, error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	ret, specificReturn := fake.desiredLRPByProcessGuidReturnsOnCall[len(fake.desiredLRPByProcessGuidArgsForCall)]
	fake.desiredLRPByProcessGuidArgsForCall = append(fake.desiredLRPByProcessGuidArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("DesiredLRPByProcessGuid", []interface{}{arg1, arg2, arg3})
	desiredLRPByProcessGuidStubCopy := fake.DesiredLRPByProcessGuidStub
	fake.desiredLRPByProcessGuidMutex.Unlock()
	if desiredLRPByProcessGuidStubCopy != nil {
		return desiredLRPByProcessGuidStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.desiredLRPByProcessGuidReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) DesiredLRPByProcessGuidCallCount() int {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return len(fake.desiredLRPByProcessGuidArgsForCall)
}

func (fake *FakeDB) DesiredLRPByProcessGuidCalls(stub func(context.Context, lager.Logger, string) (*models.DesiredLRP, error)) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = stub
}

func (fake *FakeDB) DesiredLRPByProcessGuidArgsForCall(i int) (context.Context, lager.Logger, string) {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	argsForCall := fake.desiredLRPByProcessGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) DesiredLRPByProcessGuidReturns(result1 *models.DesiredLRP, result2 error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = nil
	fake.desiredLRPByProcessGuidReturns = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPByProcessGuidReturnsOnCall(i int, result1 *models.DesiredLRP, result2 error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = nil
	if fake.desiredLRPByProcessGuidReturnsOnCall == nil {
		fake.desiredLRPByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 *models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPByProcessGuidReturnsOnCall[i] = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPSchedulingInfos(arg1 context.Context, arg2 lager.Logger, arg3 models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	ret, specificReturn := fake.desiredLRPSchedulingInfosReturnsOnCall[len(fake.desiredLRPSchedulingInfosArgsForCall)]
	fake.desiredLRPSchedulingInfosArgsForCall = append(fake.desiredLRPSchedulingInfosArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.DesiredLRPFilter
	}{arg1, arg2, arg3})
	fake.recordInvocation("DesiredLRPSchedulingInfos", []interface{}{arg1, arg2, arg3})
	desiredLRPSchedulingInfosStubCopy := fake.DesiredLRPSchedulingInfosStub
	fake.desiredLRPSchedulingInfosMutex.Unlock()
	if desiredLRPSchedulingInfosStubCopy != nil {
		return desiredLRPSchedulingInfosStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.desiredLRPSchedulingInfosReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) DesiredLRPSchedulingInfosCallCount() int {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return len(fake.desiredLRPSchedulingInfosArgsForCall)
}

func (fake *FakeDB) DesiredLRPSchedulingInfosCalls(stub func(context.Context, lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = stub
}

func (fake *FakeDB) DesiredLRPSchedulingInfosArgsForCall(i int) (context.Context, lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	argsForCall := fake.desiredLRPSchedulingInfosArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) DesiredLRPSchedulingInfosReturns(result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = nil
	fake.desiredLRPSchedulingInfosReturns = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPSchedulingInfosReturnsOnCall(i int, result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = nil
	if fake.desiredLRPSchedulingInfosReturnsOnCall == nil {
		fake.desiredLRPSchedulingInfosReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRPSchedulingInfo
			result2 error
		})
	}
	fake.desiredLRPSchedulingInfosReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPs(arg1 context.Context, arg2 lager.Logger, arg3 models.DesiredLRPFilter) ([]*models.DesiredLRP, error) {
	fake.desiredLRPsMutex.Lock()
	ret, specificReturn := fake.desiredLRPsReturnsOnCall[len(fake.desiredLRPsArgsForCall)]
	fake.desiredLRPsArgsForCall = append(fake.desiredLRPsArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.DesiredLRPFilter
	}{arg1, arg2, arg3})
	fake.recordInvocation("DesiredLRPs", []interface{}{arg1, arg2, arg3})
	desiredLRPsStubCopy := fake.DesiredLRPsStub
	fake.desiredLRPsMutex.Unlock()
	if desiredLRPsStubCopy != nil {
		return desiredLRPsStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.desiredLRPsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) DesiredLRPsCallCount() int {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return len(fake.desiredLRPsArgsForCall)
}

func (fake *FakeDB) DesiredLRPsCalls(stub func(context.Context, lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = stub
}

func (fake *FakeDB) DesiredLRPsArgsForCall(i int) (context.Context, lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	argsForCall := fake.desiredLRPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) DesiredLRPsReturns(result1 []*models.DesiredLRP, result2 error) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = nil
	fake.desiredLRPsReturns = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) DesiredLRPsReturnsOnCall(i int, result1 []*models.DesiredLRP, result2 error) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = nil
	if fake.desiredLRPsReturnsOnCall == nil {
		fake.desiredLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPsReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) EncryptionKeyLabel(arg1 context.Context, arg2 lager.Logger) (string, error) {
	fake.encryptionKeyLabelMutex.Lock()
	ret, specificReturn := fake.encryptionKeyLabelReturnsOnCall[len(fake.encryptionKeyLabelArgsForCall)]
	fake.encryptionKeyLabelArgsForCall = append(fake.encryptionKeyLabelArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
	}{arg1, arg2})
	fake.recordInvocation("EncryptionKeyLabel", []interface{}{arg1, arg2})
	encryptionKeyLabelStubCopy := fake.EncryptionKeyLabelStub
	fake.encryptionKeyLabelMutex.Unlock()
	if encryptionKeyLabelStubCopy != nil {
		return encryptionKeyLabelStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.encryptionKeyLabelReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) EncryptionKeyLabelCallCount() int {
	fake.encryptionKeyLabelMutex.RLock()
	defer fake.encryptionKeyLabelMutex.RUnlock()
	return len(fake.encryptionKeyLabelArgsForCall)
}

func (fake *FakeDB) EncryptionKeyLabelCalls(stub func(context.Context, lager.Logger) (string, error)) {
	fake.encryptionKeyLabelMutex.Lock()
	defer fake.encryptionKeyLabelMutex.Unlock()
	fake.EncryptionKeyLabelStub = stub
}

func (fake *FakeDB) EncryptionKeyLabelArgsForCall(i int) (context.Context, lager.Logger) {
	fake.encryptionKeyLabelMutex.RLock()
	defer fake.encryptionKeyLabelMutex.RUnlock()
	argsForCall := fake.encryptionKeyLabelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDB) EncryptionKeyLabelReturns(result1 string, result2 error) {
	fake.encryptionKeyLabelMutex.Lock()
	defer fake.encryptionKeyLabelMutex.Unlock()
	fake.EncryptionKeyLabelStub = nil
	fake.encryptionKeyLabelReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) EncryptionKeyLabelReturnsOnCall(i int, result1 string, result2 error) {
	fake.encryptionKeyLabelMutex.Lock()
	defer fake.encryptionKeyLabelMutex.Unlock()
	fake.EncryptionKeyLabelStub = nil
	if fake.encryptionKeyLabelReturnsOnCall == nil {
		fake.encryptionKeyLabelReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.encryptionKeyLabelReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) EvacuateActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey, arg5 *models.ActualLRPNetInfo) (*models.ActualLRP, error) {
	fake.evacuateActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateActualLRPReturnsOnCall[len(fake.evacuateActualLRPArgsForCall)]
	fake.evacuateActualLRPArgsForCall = append(fake.evacuateActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 *models.ActualLRPNetInfo
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("EvacuateActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	evacuateActualLRPStubCopy := fake.EvacuateActualLRPStub
	fake.evacuateActualLRPMutex.Unlock()
	if evacuateActualLRPStubCopy != nil {
		return evacuateActualLRPStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.evacuateActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) EvacuateActualLRPCallCount() int {
	fake.evacuateActualLRPMutex.RLock()
	defer fake.evacuateActualLRPMutex.RUnlock()
	return len(fake.evacuateActualLRPArgsForCall)
}

func (fake *FakeDB) EvacuateActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) (*models.ActualLRP, error)) {
	fake.evacuateActualLRPMutex.Lock()
	defer fake.evacuateActualLRPMutex.Unlock()
	fake.EvacuateActualLRPStub = stub
}

func (fake *FakeDB) EvacuateActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.evacuateActualLRPMutex.RLock()
	defer fake.evacuateActualLRPMutex.RUnlock()
	argsForCall := fake.evacuateActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeDB) EvacuateActualLRPReturns(result1 *models.ActualLRP, result2 error) {
	fake.evacuateActualLRPMutex.Lock()
	defer fake.evacuateActualLRPMutex.Unlock()
	fake.EvacuateActualLRPStub = nil
	fake.evacuateActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) EvacuateActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 error) {
	fake.evacuateActualLRPMutex.Lock()
	defer fake.evacuateActualLRPMutex.Unlock()
	fake.EvacuateActualLRPStub = nil
	if fake.evacuateActualLRPReturnsOnCall == nil {
		fake.evacuateActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 error
		})
	}
	fake.evacuateActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) FailActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey, arg4 string) (*models.ActualLRP, *models.ActualLRP, error) {
	fake.failActualLRPMutex.Lock()
	ret, specificReturn := fake.failActualLRPReturnsOnCall[len(fake.failActualLRPArgsForCall)]
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("FailActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	failActualLRPStubCopy := fake.FailActualLRPStub
	fake.failActualLRPMutex.Unlock()
	if failActualLRPStubCopy != nil {
		return failActualLRPStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.failActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDB) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeDB) FailActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey, string) (*models.ActualLRP, *models.ActualLRP, error)) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = stub
}

func (fake *FakeDB) FailActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	argsForCall := fake.failActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDB) FailActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) FailActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = nil
	if fake.failActualLRPReturnsOnCall == nil {
		fake.failActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.failActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) FailTask(arg1 context.Context, arg2 lager.Logger, arg3 string, arg4 string) (*models.Task, *models.Task, error) {
	fake.failTaskMutex.Lock()
	ret, specificReturn := fake.failTaskReturnsOnCall[len(fake.failTaskArgsForCall)]
	fake.failTaskArgsForCall = append(fake.failTaskArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("FailTask", []interface{}{arg1, arg2, arg3, arg4})
	failTaskStubCopy := fake.FailTaskStub
	fake.failTaskMutex.Unlock()
	if failTaskStubCopy != nil {
		return failTaskStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.failTaskReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDB) FailTaskCallCount() int {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return len(fake.failTaskArgsForCall)
}

func (fake *FakeDB) FailTaskCalls(stub func(context.Context, lager.Logger, string, string) (*models.Task, *models.Task, error)) {
	fake.failTaskMutex.Lock()
	defer fake.failTaskMutex.Unlock()
	fake.FailTaskStub = stub
}

func (fake *FakeDB) FailTaskArgsForCall(i int) (context.Context, lager.Logger, string, string) {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	argsForCall := fake.failTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDB) FailTaskReturns(result1 *models.Task, result2 *models.Task, result3 error) {
	fake.failTaskMutex.Lock()
	defer fake.failTaskMutex.Unlock()
	fake.FailTaskStub = nil
	fake.failTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) FailTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 error) {
	fake.failTaskMutex.Lock()
	defer fake.failTaskMutex.Unlock()
	fake.FailTaskStub = nil
	if fake.failTaskReturnsOnCall == nil {
		fake.failTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 error
		})
	}
	fake.failTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) FreshDomains(arg1 context.Context, arg2 lager.Logger) ([]string, error) {
	fake.freshDomainsMutex.Lock()
	ret, specificReturn := fake.freshDomainsReturnsOnCall[len(fake.freshDomainsArgsForCall)]
	fake.freshDomainsArgsForCall = append(fake.freshDomainsArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
	}{arg1, arg2})
	fake.recordInvocation("FreshDomains", []interface{}{arg1, arg2})
	freshDomainsStubCopy := fake.FreshDomainsStub
	fake.freshDomainsMutex.Unlock()
	if freshDomainsStubCopy != nil {
		return freshDomainsStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.freshDomainsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) FreshDomainsCallCount() int {
	fake.freshDomainsMutex.RLock()
	defer fake.freshDomainsMutex.RUnlock()
	return len(fake.freshDomainsArgsForCall)
}

func (fake *FakeDB) FreshDomainsCalls(stub func(context.Context, lager.Logger) ([]string, error)) {
	fake.freshDomainsMutex.Lock()
	defer fake.freshDomainsMutex.Unlock()
	fake.FreshDomainsStub = stub
}

func (fake *FakeDB) FreshDomainsArgsForCall(i int) (context.Context, lager.Logger) {
	fake.freshDomainsMutex.RLock()
	defer fake.freshDomainsMutex.RUnlock()
	argsForCall := fake.freshDomainsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDB) FreshDomainsReturns(result1 []string, result2 error) {
	fake.freshDomainsMutex.Lock()
	defer fake.freshDomainsMutex.Unlock()
	fake.FreshDomainsStub = nil
	fake.freshDomainsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) FreshDomainsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.freshDomainsMutex.Lock()
	defer fake.freshDomainsMutex.Unlock()
	fake.FreshDomainsStub = nil
	if fake.freshDomainsReturnsOnCall == nil {
		fake.freshDomainsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.freshDomainsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) PerformEncryption(arg1 context.Context, arg2 lager.Logger) error {
	fake.performEncryptionMutex.Lock()
	ret, specificReturn := fake.performEncryptionReturnsOnCall[len(fake.performEncryptionArgsForCall)]
	fake.performEncryptionArgsForCall = append(fake.performEncryptionArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
	}{arg1, arg2})
	fake.recordInvocation("PerformEncryption", []interface{}{arg1, arg2})
	performEncryptionStubCopy := fake.PerformEncryptionStub
	fake.performEncryptionMutex.Unlock()
	if performEncryptionStubCopy != nil {
		return performEncryptionStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.performEncryptionReturns
	return fakeReturns.result1
}

func (fake *FakeDB) PerformEncryptionCallCount() int {
	fake.performEncryptionMutex.RLock()
	defer fake.performEncryptionMutex.RUnlock()
	return len(fake.performEncryptionArgsForCall)
}

func (fake *FakeDB) PerformEncryptionCalls(stub func(context.Context, lager.Logger) error) {
	fake.performEncryptionMutex.Lock()
	defer fake.performEncryptionMutex.Unlock()
	fake.PerformEncryptionStub = stub
}

func (fake *FakeDB) PerformEncryptionArgsForCall(i int) (context.Context, lager.Logger) {
	fake.performEncryptionMutex.RLock()
	defer fake.performEncryptionMutex.RUnlock()
	argsForCall := fake.performEncryptionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDB) PerformEncryptionReturns(result1 error) {
	fake.performEncryptionMutex.Lock()
	defer fake.performEncryptionMutex.Unlock()
	fake.PerformEncryptionStub = nil
	fake.performEncryptionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) PerformEncryptionReturnsOnCall(i int, result1 error) {
	fake.performEncryptionMutex.Lock()
	defer fake.performEncryptionMutex.Unlock()
	fake.PerformEncryptionStub = nil
	if fake.performEncryptionReturnsOnCall == nil {
		fake.performEncryptionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.performEncryptionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RejectTask(arg1 context.Context, arg2 lager.Logger, arg3 string, arg4 string) (*models.Task, *models.Task, error) {
	fake.rejectTaskMutex.Lock()
	ret, specificReturn := fake.rejectTaskReturnsOnCall[len(fake.rejectTaskArgsForCall)]
	fake.rejectTaskArgsForCall = append(fake.rejectTaskArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("RejectTask", []interface{}{arg1, arg2, arg3, arg4})
	rejectTaskStubCopy := fake.RejectTaskStub
	fake.rejectTaskMutex.Unlock()
	if rejectTaskStubCopy != nil {
		return rejectTaskStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.rejectTaskReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDB) RejectTaskCallCount() int {
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	return len(fake.rejectTaskArgsForCall)
}

func (fake *FakeDB) RejectTaskCalls(stub func(context.Context, lager.Logger, string, string) (*models.Task, *models.Task, error)) {
	fake.rejectTaskMutex.Lock()
	defer fake.rejectTaskMutex.Unlock()
	fake.RejectTaskStub = stub
}

func (fake *FakeDB) RejectTaskArgsForCall(i int) (context.Context, lager.Logger, string, string) {
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	argsForCall := fake.rejectTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDB) RejectTaskReturns(result1 *models.Task, result2 *models.Task, result3 error) {
	fake.rejectTaskMutex.Lock()
	defer fake.rejectTaskMutex.Unlock()
	fake.RejectTaskStub = nil
	fake.rejectTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) RejectTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 error) {
	fake.rejectTaskMutex.Lock()
	defer fake.rejectTaskMutex.Unlock()
	fake.RejectTaskStub = nil
	if fake.rejectTaskReturnsOnCall == nil {
		fake.rejectTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 error
		})
	}
	fake.rejectTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) RemoveActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 string, arg4 int32, arg5 *models.ActualLRPInstanceKey) error {
	fake.removeActualLRPMutex.Lock()
	ret, specificReturn := fake.removeActualLRPReturnsOnCall[len(fake.removeActualLRPArgsForCall)]
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 int32
		arg5 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("RemoveActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	removeActualLRPStubCopy := fake.RemoveActualLRPStub
	fake.removeActualLRPMutex.Unlock()
	if removeActualLRPStubCopy != nil {
		return removeActualLRPStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeActualLRPReturns
	return fakeReturns.result1
}

func (fake *FakeDB) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeDB) RemoveActualLRPCalls(stub func(context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = stub
}

func (fake *FakeDB) RemoveActualLRPArgsForCall(i int) (context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	argsForCall := fake.removeActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeDB) RemoveActualLRPReturns(result1 error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveActualLRPReturnsOnCall(i int, result1 error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = nil
	if fake.removeActualLRPReturnsOnCall == nil {
		fake.removeActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveDesiredLRP(arg1 context.Context, arg2 lager.Logger, arg3 string) error {
	fake.removeDesiredLRPMutex.Lock()
	ret, specificReturn := fake.removeDesiredLRPReturnsOnCall[len(fake.removeDesiredLRPArgsForCall)]
	fake.removeDesiredLRPArgsForCall = append(fake.removeDesiredLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveDesiredLRP", []interface{}{arg1, arg2, arg3})
	removeDesiredLRPStubCopy := fake.RemoveDesiredLRPStub
	fake.removeDesiredLRPMutex.Unlock()
	if removeDesiredLRPStubCopy != nil {
		return removeDesiredLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeDesiredLRPReturns
	return fakeReturns.result1
}

func (fake *FakeDB) RemoveDesiredLRPCallCount() int {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return len(fake.removeDesiredLRPArgsForCall)
}

func (fake *FakeDB) RemoveDesiredLRPCalls(stub func(context.Context, lager.Logger, string) error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = stub
}

func (fake *FakeDB) RemoveDesiredLRPArgsForCall(i int) (context.Context, lager.Logger, string) {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	argsForCall := fake.removeDesiredLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) RemoveDesiredLRPReturns(result1 error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = nil
	fake.removeDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveDesiredLRPReturnsOnCall(i int, result1 error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = nil
	if fake.removeDesiredLRPReturnsOnCall == nil {
		fake.removeDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeDesiredLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveEvacuatingActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey) error {
	fake.removeEvacuatingActualLRPMutex.Lock()
	ret, specificReturn := fake.removeEvacuatingActualLRPReturnsOnCall[len(fake.removeEvacuatingActualLRPArgsForCall)]
	fake.removeEvacuatingActualLRPArgsForCall = append(fake.removeEvacuatingActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("RemoveEvacuatingActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	removeEvacuatingActualLRPStubCopy := fake.RemoveEvacuatingActualLRPStub
	fake.removeEvacuatingActualLRPMutex.Unlock()
	if removeEvacuatingActualLRPStubCopy != nil {
		return removeEvacuatingActualLRPStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeEvacuatingActualLRPReturns
	return fakeReturns.result1
}

func (fake *FakeDB) RemoveEvacuatingActualLRPCallCount() int {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return len(fake.removeEvacuatingActualLRPArgsForCall)
}

func (fake *FakeDB) RemoveEvacuatingActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error) {
	fake.removeEvacuatingActualLRPMutex.Lock()
	defer fake.removeEvacuatingActualLRPMutex.Unlock()
	fake.RemoveEvacuatingActualLRPStub = stub
}

func (fake *FakeDB) RemoveEvacuatingActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	argsForCall := fake.removeEvacuatingActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDB) RemoveEvacuatingActualLRPReturns(result1 error) {
	fake.removeEvacuatingActualLRPMutex.Lock()
	defer fake.removeEvacuatingActualLRPMutex.Unlock()
	fake.RemoveEvacuatingActualLRPStub = nil
	fake.removeEvacuatingActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveEvacuatingActualLRPReturnsOnCall(i int, result1 error) {
	fake.removeEvacuatingActualLRPMutex.Lock()
	defer fake.removeEvacuatingActualLRPMutex.Unlock()
	fake.RemoveEvacuatingActualLRPStub = nil
	if fake.removeEvacuatingActualLRPReturnsOnCall == nil {
		fake.removeEvacuatingActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeEvacuatingActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) RemoveSuspectActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey) (*models.ActualLRP, error) {
	fake.removeSuspectActualLRPMutex.Lock()
	ret, specificReturn := fake.removeSuspectActualLRPReturnsOnCall[len(fake.removeSuspectActualLRPArgsForCall)]
	fake.removeSuspectActualLRPArgsForCall = append(fake.removeSuspectActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveSuspectActualLRP", []interface{}{arg1, arg2, arg3})
	removeSuspectActualLRPStubCopy := fake.RemoveSuspectActualLRPStub
	fake.removeSuspectActualLRPMutex.Unlock()
	if removeSuspectActualLRPStubCopy != nil {
		return removeSuspectActualLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.removeSuspectActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) RemoveSuspectActualLRPCallCount() int {
	fake.removeSuspectActualLRPMutex.RLock()
	defer fake.removeSuspectActualLRPMutex.RUnlock()
	return len(fake.removeSuspectActualLRPArgsForCall)
}

func (fake *FakeDB) RemoveSuspectActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey) (*models.ActualLRP, error)) {
	fake.removeSuspectActualLRPMutex.Lock()
	defer fake.removeSuspectActualLRPMutex.Unlock()
	fake.RemoveSuspectActualLRPStub = stub
}

func (fake *FakeDB) RemoveSuspectActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey) {
	fake.removeSuspectActualLRPMutex.RLock()
	defer fake.removeSuspectActualLRPMutex.RUnlock()
	argsForCall := fake.removeSuspectActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) RemoveSuspectActualLRPReturns(result1 *models.ActualLRP, result2 error) {
	fake.removeSuspectActualLRPMutex.Lock()
	defer fake.removeSuspectActualLRPMutex.Unlock()
	fake.RemoveSuspectActualLRPStub = nil
	fake.removeSuspectActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) RemoveSuspectActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 error) {
	fake.removeSuspectActualLRPMutex.Lock()
	defer fake.removeSuspectActualLRPMutex.Unlock()
	fake.RemoveSuspectActualLRPStub = nil
	if fake.removeSuspectActualLRPReturnsOnCall == nil {
		fake.removeSuspectActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 error
		})
	}
	fake.removeSuspectActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ResolvingTask(arg1 context.Context, arg2 lager.Logger, arg3 string) (*models.Task, *models.Task, error) {
	fake.resolvingTaskMutex.Lock()
	ret, specificReturn := fake.resolvingTaskReturnsOnCall[len(fake.resolvingTaskArgsForCall)]
	fake.resolvingTaskArgsForCall = append(fake.resolvingTaskArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("ResolvingTask", []interface{}{arg1, arg2, arg3})
	resolvingTaskStubCopy := fake.ResolvingTaskStub
	fake.resolvingTaskMutex.Unlock()
	if resolvingTaskStubCopy != nil {
		return resolvingTaskStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.resolvingTaskReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDB) ResolvingTaskCallCount() int {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return len(fake.resolvingTaskArgsForCall)
}

func (fake *FakeDB) ResolvingTaskCalls(stub func(context.Context, lager.Logger, string) (*models.Task, *models.Task, error)) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = stub
}

func (fake *FakeDB) ResolvingTaskArgsForCall(i int) (context.Context, lager.Logger, string) {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	argsForCall := fake.resolvingTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) ResolvingTaskReturns(result1 *models.Task, result2 *models.Task, result3 error) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = nil
	fake.resolvingTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) ResolvingTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 error) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = nil
	if fake.resolvingTaskReturnsOnCall == nil {
		fake.resolvingTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 error
		})
	}
	fake.resolvingTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) SetEncryptionKeyLabel(arg1 context.Context, arg2 lager.Logger, arg3 string) error {
	fake.setEncryptionKeyLabelMutex.Lock()
	ret, specificReturn := fake.setEncryptionKeyLabelReturnsOnCall[len(fake.setEncryptionKeyLabelArgsForCall)]
	fake.setEncryptionKeyLabelArgsForCall = append(fake.setEncryptionKeyLabelArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetEncryptionKeyLabel", []interface{}{arg1, arg2, arg3})
	setEncryptionKeyLabelStubCopy := fake.SetEncryptionKeyLabelStub
	fake.setEncryptionKeyLabelMutex.Unlock()
	if setEncryptionKeyLabelStubCopy != nil {
		return setEncryptionKeyLabelStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setEncryptionKeyLabelReturns
	return fakeReturns.result1
}

func (fake *FakeDB) SetEncryptionKeyLabelCallCount() int {
	fake.setEncryptionKeyLabelMutex.RLock()
	defer fake.setEncryptionKeyLabelMutex.RUnlock()
	return len(fake.setEncryptionKeyLabelArgsForCall)
}

func (fake *FakeDB) SetEncryptionKeyLabelCalls(stub func(context.Context, lager.Logger, string) error) {
	fake.setEncryptionKeyLabelMutex.Lock()
	defer fake.setEncryptionKeyLabelMutex.Unlock()
	fake.SetEncryptionKeyLabelStub = stub
}

func (fake *FakeDB) SetEncryptionKeyLabelArgsForCall(i int) (context.Context, lager.Logger, string) {
	fake.setEncryptionKeyLabelMutex.RLock()
	defer fake.setEncryptionKeyLabelMutex.RUnlock()
	argsForCall := fake.setEncryptionKeyLabelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) SetEncryptionKeyLabelReturns(result1 error) {
	fake.setEncryptionKeyLabelMutex.Lock()
	defer fake.setEncryptionKeyLabelMutex.Unlock()
	fake.SetEncryptionKeyLabelStub = nil
	fake.setEncryptionKeyLabelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) SetEncryptionKeyLabelReturnsOnCall(i int, result1 error) {
	fake.setEncryptionKeyLabelMutex.Lock()
	defer fake.setEncryptionKeyLabelMutex.Unlock()
	fake.SetEncryptionKeyLabelStub = nil
	if fake.setEncryptionKeyLabelReturnsOnCall == nil {
		fake.setEncryptionKeyLabelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setEncryptionKeyLabelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) SetVersion(arg1 context.Context, arg2 lager.Logger, arg3 *models.Version) error {
	fake.setVersionMutex.Lock()
	ret, specificReturn := fake.setVersionReturnsOnCall[len(fake.setVersionArgsForCall)]
	fake.setVersionArgsForCall = append(fake.setVersionArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.Version
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetVersion", []interface{}{arg1, arg2, arg3})
	setVersionStubCopy := fake.SetVersionStub
	fake.setVersionMutex.Unlock()
	if setVersionStubCopy != nil {
		return setVersionStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setVersionReturns
	return fakeReturns.result1
}

func (fake *FakeDB) SetVersionCallCount() int {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	return len(fake.setVersionArgsForCall)
}

func (fake *FakeDB) SetVersionCalls(stub func(context.Context, lager.Logger, *models.Version) error) {
	fake.setVersionMutex.Lock()
	defer fake.setVersionMutex.Unlock()
	fake.SetVersionStub = stub
}

func (fake *FakeDB) SetVersionArgsForCall(i int) (context.Context, lager.Logger, *models.Version) {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	argsForCall := fake.setVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) SetVersionReturns(result1 error) {
	fake.setVersionMutex.Lock()
	defer fake.setVersionMutex.Unlock()
	fake.SetVersionStub = nil
	fake.setVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) SetVersionReturnsOnCall(i int, result1 error) {
	fake.setVersionMutex.Lock()
	defer fake.setVersionMutex.Unlock()
	fake.SetVersionStub = nil
	if fake.setVersionReturnsOnCall == nil {
		fake.setVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) StartActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey, arg5 *models.ActualLRPNetInfo) (*models.ActualLRP, *models.ActualLRP, error) {
	fake.startActualLRPMutex.Lock()
	ret, specificReturn := fake.startActualLRPReturnsOnCall[len(fake.startActualLRPArgsForCall)]
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 *models.ActualLRPNetInfo
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("StartActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	startActualLRPStubCopy := fake.StartActualLRPStub
	fake.startActualLRPMutex.Unlock()
	if startActualLRPStubCopy != nil {
		return startActualLRPStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.startActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDB) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeDB) StartActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) (*models.ActualLRP, *models.ActualLRP, error)) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = stub
}

func (fake *FakeDB) StartActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	argsForCall := fake.startActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeDB) StartActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) StartActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = nil
	if fake.startActualLRPReturnsOnCall == nil {
		fake.startActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.startActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) StartTask(arg1 context.Context, arg2 lager.Logger, arg3 string, arg4 string) (*models.Task, *models.Task, bool, error) {
	fake.startTaskMutex.Lock()
	ret, specificReturn := fake.startTaskReturnsOnCall[len(fake.startTaskArgsForCall)]
	fake.startTaskArgsForCall = append(fake.startTaskArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("StartTask", []interface{}{arg1, arg2, arg3, arg4})
	startTaskStubCopy := fake.StartTaskStub
	fake.startTaskMutex.Unlock()
	if startTaskStubCopy != nil {
		return startTaskStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.startTaskReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeDB) StartTaskCallCount() int {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return len(fake.startTaskArgsForCall)
}

func (fake *FakeDB) StartTaskCalls(stub func(context.Context, lager.Logger, string, string) (*models.Task, *models.Task, bool, error)) {
	fake.startTaskMutex.Lock()
	defer fake.startTaskMutex.Unlock()
	fake.StartTaskStub = stub
}

func (fake *FakeDB) StartTaskArgsForCall(i int) (context.Context, lager.Logger, string, string) {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	argsForCall := fake.startTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDB) StartTaskReturns(result1 *models.Task, result2 *models.Task, result3 bool, result4 error) {
	fake.startTaskMutex.Lock()
	defer fake.startTaskMutex.Unlock()
	fake.StartTaskStub = nil
	fake.startTaskReturns = struct {
		result1 *models.Task
		result2 *models.Task
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) StartTaskReturnsOnCall(i int, result1 *models.Task, result2 *models.Task, result3 bool, result4 error) {
	fake.startTaskMutex.Lock()
	defer fake.startTaskMutex.Unlock()
	fake.StartTaskStub = nil
	if fake.startTaskReturnsOnCall == nil {
		fake.startTaskReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 *models.Task
			result3 bool
			result4 error
		})
	}
	fake.startTaskReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 *models.Task
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeDB) TaskByGuid(arg1 context.Context, arg2 lager.Logger, arg3 string) (*models.Task, error) {
	fake.taskByGuidMutex.Lock()
	ret, specificReturn := fake.taskByGuidReturnsOnCall[len(fake.taskByGuidArgsForCall)]
	fake.taskByGuidArgsForCall = append(fake.taskByGuidArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("TaskByGuid", []interface{}{arg1, arg2, arg3})
	taskByGuidStubCopy := fake.TaskByGuidStub
	fake.taskByGuidMutex.Unlock()
	if taskByGuidStubCopy != nil {
		return taskByGuidStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.taskByGuidReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) TaskByGuidCallCount() int {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return len(fake.taskByGuidArgsForCall)
}

func (fake *FakeDB) TaskByGuidCalls(stub func(context.Context, lager.Logger, string) (*models.Task, error)) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = stub
}

func (fake *FakeDB) TaskByGuidArgsForCall(i int) (context.Context, lager.Logger, string) {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	argsForCall := fake.taskByGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) TaskByGuidReturns(result1 *models.Task, result2 error) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = nil
	fake.taskByGuidReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) TaskByGuidReturnsOnCall(i int, result1 *models.Task, result2 error) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = nil
	if fake.taskByGuidReturnsOnCall == nil {
		fake.taskByGuidReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 error
		})
	}
	fake.taskByGuidReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) Tasks(arg1 context.Context, arg2 lager.Logger, arg3 models.TaskFilter) ([]*models.Task, error) {
	fake.tasksMutex.Lock()
	ret, specificReturn := fake.tasksReturnsOnCall[len(fake.tasksArgsForCall)]
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.TaskFilter
	}{arg1, arg2, arg3})
	fake.recordInvocation("Tasks", []interface{}{arg1, arg2, arg3})
	tasksStubCopy := fake.TasksStub
	fake.tasksMutex.Unlock()
	if tasksStubCopy != nil {
		return tasksStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tasksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeDB) TasksCalls(stub func(context.Context, lager.Logger, models.TaskFilter) ([]*models.Task, error)) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = stub
}

func (fake *FakeDB) TasksArgsForCall(i int) (context.Context, lager.Logger, models.TaskFilter) {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	argsForCall := fake.tasksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) TasksReturns(result1 []*models.Task, result2 error) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) TasksReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = nil
	if fake.tasksReturnsOnCall == nil {
		fake.tasksReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) UnclaimActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey) (*models.ActualLRP, *models.ActualLRP, error) {
	fake.unclaimActualLRPMutex.Lock()
	ret, specificReturn := fake.unclaimActualLRPReturnsOnCall[len(fake.unclaimActualLRPArgsForCall)]
	fake.unclaimActualLRPArgsForCall = append(fake.unclaimActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("UnclaimActualLRP", []interface{}{arg1, arg2, arg3})
	unclaimActualLRPStubCopy := fake.UnclaimActualLRPStub
	fake.unclaimActualLRPMutex.Unlock()
	if unclaimActualLRPStubCopy != nil {
		return unclaimActualLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.unclaimActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDB) UnclaimActualLRPCallCount() int {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	return len(fake.unclaimActualLRPArgsForCall)
}

func (fake *FakeDB) UnclaimActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey) (*models.ActualLRP, *models.ActualLRP, error)) {
	fake.unclaimActualLRPMutex.Lock()
	defer fake.unclaimActualLRPMutex.Unlock()
	fake.UnclaimActualLRPStub = stub
}

func (fake *FakeDB) UnclaimActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey) {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	argsForCall := fake.unclaimActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDB) UnclaimActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.unclaimActualLRPMutex.Lock()
	defer fake.unclaimActualLRPMutex.Unlock()
	fake.UnclaimActualLRPStub = nil
	fake.unclaimActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) UnclaimActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.unclaimActualLRPMutex.Lock()
	defer fake.unclaimActualLRPMutex.Unlock()
	fake.UnclaimActualLRPStub = nil
	if fake.unclaimActualLRPReturnsOnCall == nil {
		fake.unclaimActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.unclaimActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDB) UpdateDesiredLRP(arg1 context.Context, arg2 lager.Logger, arg3 string, arg4 *models.DesiredLRPUpdate) (*models.DesiredLRP, error) {
	fake.updateDesiredLRPMutex.Lock()
	ret, specificReturn := fake.updateDesiredLRPReturnsOnCall[len(fake.updateDesiredLRPArgsForCall)]
	fake.updateDesiredLRPArgsForCall = append(fake.updateDesiredLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 *models.DesiredLRPUpdate
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("UpdateDesiredLRP", []interface{}{arg1, arg2, arg3, arg4})
	updateDesiredLRPStubCopy := fake.UpdateDesiredLRPStub
	fake.updateDesiredLRPMutex.Unlock()
	if updateDesiredLRPStubCopy != nil {
		return updateDesiredLRPStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateDesiredLRPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) UpdateDesiredLRPCallCount() int {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return len(fake.updateDesiredLRPArgsForCall)
}

func (fake *FakeDB) UpdateDesiredLRPCalls(stub func(context.Context, lager.Logger, string, *models.DesiredLRPUpdate) (*models.DesiredLRP, error)) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = stub
}

func (fake *FakeDB) UpdateDesiredLRPArgsForCall(i int) (context.Context, lager.Logger, string, *models.DesiredLRPUpdate) {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	argsForCall := fake.updateDesiredLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDB) UpdateDesiredLRPReturns(result1 *models.DesiredLRP, result2 error) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = nil
	fake.updateDesiredLRPReturns = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) UpdateDesiredLRPReturnsOnCall(i int, result1 *models.DesiredLRP, result2 error) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = nil
	if fake.updateDesiredLRPReturnsOnCall == nil {
		fake.updateDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 *models.DesiredLRP
			result2 error
		})
	}
	fake.updateDesiredLRPReturnsOnCall[i] = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) UpsertDomain(arg1 context.Context, arg2 lager.Logger, arg3 string, arg4 uint32) error {
	fake.upsertDomainMutex.Lock()
	ret, specificReturn := fake.upsertDomainReturnsOnCall[len(fake.upsertDomainArgsForCall)]
	fake.upsertDomainArgsForCall = append(fake.upsertDomainArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 uint32
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("UpsertDomain", []interface{}{arg1, arg2, arg3, arg4})
	upsertDomainStubCopy := fake.UpsertDomainStub
	fake.upsertDomainMutex.Unlock()
	if upsertDomainStubCopy != nil {
		return upsertDomainStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.upsertDomainReturns
	return fakeReturns.result1
}

func (fake *FakeDB) UpsertDomainCallCount() int {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return len(fake.upsertDomainArgsForCall)
}

func (fake *FakeDB) UpsertDomainCalls(stub func(context.Context, lager.Logger, string, uint32) error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = stub
}

func (fake *FakeDB) UpsertDomainArgsForCall(i int) (context.Context, lager.Logger, string, uint32) {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	argsForCall := fake.upsertDomainArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDB) UpsertDomainReturns(result1 error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = nil
	fake.upsertDomainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) UpsertDomainReturnsOnCall(i int, result1 error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = nil
	if fake.upsertDomainReturnsOnCall == nil {
		fake.upsertDomainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upsertDomainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) Version(arg1 context.Context, arg2 lager.Logger) (*models.Version, error) {
	fake.versionMutex.Lock()
	ret, specificReturn := fake.versionReturnsOnCall[len(fake.versionArgsForCall)]
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
	}{arg1, arg2})
	fake.recordInvocation("Version", []interface{}{arg1, arg2})
	versionStubCopy := fake.VersionStub
	fake.versionMutex.Unlock()
	if versionStubCopy != nil {
		return versionStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.versionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeDB) VersionCalls(stub func(context.Context, lager.Logger) (*models.Version, error)) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = stub
}

func (fake *FakeDB) VersionArgsForCall(i int) (context.Context, lager.Logger) {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	argsForCall := fake.versionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDB) VersionReturns(result1 *models.Version, result2 error) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 *models.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) VersionReturnsOnCall(i int, result1 *models.Version, result2 error) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	if fake.versionReturnsOnCall == nil {
		fake.versionReturnsOnCall = make(map[int]struct {
			result1 *models.Version
			result2 error
		})
	}
	fake.versionReturnsOnCall[i] = struct {
		result1 *models.Version
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	fake.encryptionKeyLabelMutex.RLock()
	defer fake.encryptionKeyLabelMutex.RUnlock()
	fake.evacuateActualLRPMutex.RLock()
	defer fake.evacuateActualLRPMutex.RUnlock()
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	fake.freshDomainsMutex.RLock()
	defer fake.freshDomainsMutex.RUnlock()
	fake.performEncryptionMutex.RLock()
	defer fake.performEncryptionMutex.RUnlock()
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	fake.removeSuspectActualLRPMutex.RLock()
	defer fake.removeSuspectActualLRPMutex.RUnlock()
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	fake.setEncryptionKeyLabelMutex.RLock()
	defer fake.setEncryptionKeyLabelMutex.RUnlock()
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.DB = new(FakeDB)
