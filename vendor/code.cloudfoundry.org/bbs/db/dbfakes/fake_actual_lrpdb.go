// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"context"
	"sync"

	"code.cloudfoundry.org/bbs/db"
	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/lager"
)

type FakeActualLRPDB struct {
	ActualLRPsStub        func(context.Context, lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRP, error)
	actualLRPsMutex       sync.RWMutex
	actualLRPsArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.ActualLRPFilter
	}
	actualLRPsReturns struct {
		result1 []*models.ActualLRP
		result2 error
	}
	actualLRPsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRP
		result2 error
	}
	ChangeActualLRPPresenceStub        func(context.Context, lager.Logger, *models.ActualLRPKey, models.ActualLRP_Presence, models.ActualLRP_Presence) (*models.ActualLRP, *models.ActualLRP, error)
	changeActualLRPPresenceMutex       sync.RWMutex
	changeActualLRPPresenceArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 models.ActualLRP_Presence
		arg5 models.ActualLRP_Presence
	}
	changeActualLRPPresenceReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	changeActualLRPPresenceReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	ClaimActualLRPStub        func(context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) (*models.ActualLRP, *models.ActualLRP, error)
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 int32
		arg5 *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	claimActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	CountActualLRPsByStateStub        func(context.Context, lager.Logger) (int, int, int, int, int)
	countActualLRPsByStateMutex       sync.RWMutex
	countActualLRPsByStateArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
	}
	countActualLRPsByStateReturns struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}
	countActualLRPsByStateReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}
	CountDesiredInstancesStub        func(context.Context, lager.Logger) int
	countDesiredInstancesMutex       sync.RWMutex
	countDesiredInstancesArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
	}
	countDesiredInstancesReturns struct {
		result1 int
	}
	countDesiredInstancesReturnsOnCall map[int]struct {
		result1 int
	}
	CrashActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) (*models.ActualLRP, *models.ActualLRP, bool, error)
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 string
	}
	crashActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}
	crashActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}
	CreateUnclaimedActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey) (*models.ActualLRP, error)
	createUnclaimedActualLRPMutex       sync.RWMutex
	createUnclaimedActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
	}
	createUnclaimedActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 error
	}
	createUnclaimedActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 error
	}
	FailActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey, string) (*models.ActualLRP, *models.ActualLRP, error)
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 string
	}
	failActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	failActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	RemoveActualLRPStub        func(context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 int32
		arg5 *models.ActualLRPInstanceKey
	}
	removeActualLRPReturns struct {
		result1 error
	}
	removeActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	StartActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) (*models.ActualLRP, *models.ActualLRP, error)
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 *models.ActualLRPNetInfo
	}
	startActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	startActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	UnclaimActualLRPStub        func(context.Context, lager.Logger, *models.ActualLRPKey) (*models.ActualLRP, *models.ActualLRP, error)
	unclaimActualLRPMutex       sync.RWMutex
	unclaimActualLRPArgsForCall []struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
	}
	unclaimActualLRPReturns struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	unclaimActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeActualLRPDB) ActualLRPs(arg1 context.Context, arg2 lager.Logger, arg3 models.ActualLRPFilter) ([]*models.ActualLRP, error) {
	fake.actualLRPsMutex.Lock()
	ret, specificReturn := fake.actualLRPsReturnsOnCall[len(fake.actualLRPsArgsForCall)]
	fake.actualLRPsArgsForCall = append(fake.actualLRPsArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 models.ActualLRPFilter
	}{arg1, arg2, arg3})
	fake.recordInvocation("ActualLRPs", []interface{}{arg1, arg2, arg3})
	actualLRPsStubCopy := fake.ActualLRPsStub
	fake.actualLRPsMutex.Unlock()
	if actualLRPsStubCopy != nil {
		return actualLRPsStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.actualLRPsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeActualLRPDB) ActualLRPsCallCount() int {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	return len(fake.actualLRPsArgsForCall)
}

func (fake *FakeActualLRPDB) ActualLRPsCalls(stub func(context.Context, lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRP, error)) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = stub
}

func (fake *FakeActualLRPDB) ActualLRPsArgsForCall(i int) (context.Context, lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	argsForCall := fake.actualLRPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeActualLRPDB) ActualLRPsReturns(result1 []*models.ActualLRP, result2 error) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = nil
	fake.actualLRPsReturns = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) ActualLRPsReturnsOnCall(i int, result1 []*models.ActualLRP, result2 error) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = nil
	if fake.actualLRPsReturnsOnCall == nil {
		fake.actualLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRP
			result2 error
		})
	}
	fake.actualLRPsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) ChangeActualLRPPresence(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey, arg4 models.ActualLRP_Presence, arg5 models.ActualLRP_Presence) (*models.ActualLRP, *models.ActualLRP, error) {
	fake.changeActualLRPPresenceMutex.Lock()
	ret, specificReturn := fake.changeActualLRPPresenceReturnsOnCall[len(fake.changeActualLRPPresenceArgsForCall)]
	fake.changeActualLRPPresenceArgsForCall = append(fake.changeActualLRPPresenceArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 models.ActualLRP_Presence
		arg5 models.ActualLRP_Presence
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("ChangeActualLRPPresence", []interface{}{arg1, arg2, arg3, arg4, arg5})
	changeActualLRPPresenceStubCopy := fake.ChangeActualLRPPresenceStub
	fake.changeActualLRPPresenceMutex.Unlock()
	if changeActualLRPPresenceStubCopy != nil {
		return changeActualLRPPresenceStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.changeActualLRPPresenceReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeActualLRPDB) ChangeActualLRPPresenceCallCount() int {
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	return len(fake.changeActualLRPPresenceArgsForCall)
}

func (fake *FakeActualLRPDB) ChangeActualLRPPresenceCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey, models.ActualLRP_Presence, models.ActualLRP_Presence) (*models.ActualLRP, *models.ActualLRP, error)) {
	fake.changeActualLRPPresenceMutex.Lock()
	defer fake.changeActualLRPPresenceMutex.Unlock()
	fake.ChangeActualLRPPresenceStub = stub
}

func (fake *FakeActualLRPDB) ChangeActualLRPPresenceArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey, models.ActualLRP_Presence, models.ActualLRP_Presence) {
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	argsForCall := fake.changeActualLRPPresenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeActualLRPDB) ChangeActualLRPPresenceReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.changeActualLRPPresenceMutex.Lock()
	defer fake.changeActualLRPPresenceMutex.Unlock()
	fake.ChangeActualLRPPresenceStub = nil
	fake.changeActualLRPPresenceReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) ChangeActualLRPPresenceReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.changeActualLRPPresenceMutex.Lock()
	defer fake.changeActualLRPPresenceMutex.Unlock()
	fake.ChangeActualLRPPresenceStub = nil
	if fake.changeActualLRPPresenceReturnsOnCall == nil {
		fake.changeActualLRPPresenceReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.changeActualLRPPresenceReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) ClaimActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 string, arg4 int32, arg5 *models.ActualLRPInstanceKey) (*models.ActualLRP, *models.ActualLRP, error) {
	fake.claimActualLRPMutex.Lock()
	ret, specificReturn := fake.claimActualLRPReturnsOnCall[len(fake.claimActualLRPArgsForCall)]
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 int32
		arg5 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("ClaimActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	claimActualLRPStubCopy := fake.ClaimActualLRPStub
	fake.claimActualLRPMutex.Unlock()
	if claimActualLRPStubCopy != nil {
		return claimActualLRPStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.claimActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeActualLRPDB) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) ClaimActualLRPCalls(stub func(context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) (*models.ActualLRP, *models.ActualLRP, error)) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = stub
}

func (fake *FakeActualLRPDB) ClaimActualLRPArgsForCall(i int) (context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	argsForCall := fake.claimActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeActualLRPDB) ClaimActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) ClaimActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = nil
	if fake.claimActualLRPReturnsOnCall == nil {
		fake.claimActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.claimActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) CountActualLRPsByState(arg1 context.Context, arg2 lager.Logger) (int, int, int, int, int) {
	fake.countActualLRPsByStateMutex.Lock()
	ret, specificReturn := fake.countActualLRPsByStateReturnsOnCall[len(fake.countActualLRPsByStateArgsForCall)]
	fake.countActualLRPsByStateArgsForCall = append(fake.countActualLRPsByStateArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
	}{arg1, arg2})
	fake.recordInvocation("CountActualLRPsByState", []interface{}{arg1, arg2})
	countActualLRPsByStateStubCopy := fake.CountActualLRPsByStateStub
	fake.countActualLRPsByStateMutex.Unlock()
	if countActualLRPsByStateStubCopy != nil {
		return countActualLRPsByStateStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4, ret.result5
	}
	fakeReturns := fake.countActualLRPsByStateReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4, fakeReturns.result5
}

func (fake *FakeActualLRPDB) CountActualLRPsByStateCallCount() int {
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	return len(fake.countActualLRPsByStateArgsForCall)
}

func (fake *FakeActualLRPDB) CountActualLRPsByStateCalls(stub func(context.Context, lager.Logger) (int, int, int, int, int)) {
	fake.countActualLRPsByStateMutex.Lock()
	defer fake.countActualLRPsByStateMutex.Unlock()
	fake.CountActualLRPsByStateStub = stub
}

func (fake *FakeActualLRPDB) CountActualLRPsByStateArgsForCall(i int) (context.Context, lager.Logger) {
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	argsForCall := fake.countActualLRPsByStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeActualLRPDB) CountActualLRPsByStateReturns(result1 int, result2 int, result3 int, result4 int, result5 int) {
	fake.countActualLRPsByStateMutex.Lock()
	defer fake.countActualLRPsByStateMutex.Unlock()
	fake.CountActualLRPsByStateStub = nil
	fake.countActualLRPsByStateReturns = struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeActualLRPDB) CountActualLRPsByStateReturnsOnCall(i int, result1 int, result2 int, result3 int, result4 int, result5 int) {
	fake.countActualLRPsByStateMutex.Lock()
	defer fake.countActualLRPsByStateMutex.Unlock()
	fake.CountActualLRPsByStateStub = nil
	if fake.countActualLRPsByStateReturnsOnCall == nil {
		fake.countActualLRPsByStateReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 int
			result4 int
			result5 int
		})
	}
	fake.countActualLRPsByStateReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 int
		result4 int
		result5 int
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeActualLRPDB) CountDesiredInstances(arg1 context.Context, arg2 lager.Logger) int {
	fake.countDesiredInstancesMutex.Lock()
	ret, specificReturn := fake.countDesiredInstancesReturnsOnCall[len(fake.countDesiredInstancesArgsForCall)]
	fake.countDesiredInstancesArgsForCall = append(fake.countDesiredInstancesArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
	}{arg1, arg2})
	fake.recordInvocation("CountDesiredInstances", []interface{}{arg1, arg2})
	countDesiredInstancesStubCopy := fake.CountDesiredInstancesStub
	fake.countDesiredInstancesMutex.Unlock()
	if countDesiredInstancesStubCopy != nil {
		return countDesiredInstancesStubCopy(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.countDesiredInstancesReturns
	return fakeReturns.result1
}

func (fake *FakeActualLRPDB) CountDesiredInstancesCallCount() int {
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	return len(fake.countDesiredInstancesArgsForCall)
}

func (fake *FakeActualLRPDB) CountDesiredInstancesCalls(stub func(context.Context, lager.Logger) int) {
	fake.countDesiredInstancesMutex.Lock()
	defer fake.countDesiredInstancesMutex.Unlock()
	fake.CountDesiredInstancesStub = stub
}

func (fake *FakeActualLRPDB) CountDesiredInstancesArgsForCall(i int) (context.Context, lager.Logger) {
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	argsForCall := fake.countDesiredInstancesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeActualLRPDB) CountDesiredInstancesReturns(result1 int) {
	fake.countDesiredInstancesMutex.Lock()
	defer fake.countDesiredInstancesMutex.Unlock()
	fake.CountDesiredInstancesStub = nil
	fake.countDesiredInstancesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeActualLRPDB) CountDesiredInstancesReturnsOnCall(i int, result1 int) {
	fake.countDesiredInstancesMutex.Lock()
	defer fake.countDesiredInstancesMutex.Unlock()
	fake.CountDesiredInstancesStub = nil
	if fake.countDesiredInstancesReturnsOnCall == nil {
		fake.countDesiredInstancesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.countDesiredInstancesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeActualLRPDB) CrashActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey, arg5 string) (*models.ActualLRP, *models.ActualLRP, bool, error) {
	fake.crashActualLRPMutex.Lock()
	ret, specificReturn := fake.crashActualLRPReturnsOnCall[len(fake.crashActualLRPArgsForCall)]
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("CrashActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	crashActualLRPStubCopy := fake.CrashActualLRPStub
	fake.crashActualLRPMutex.Unlock()
	if crashActualLRPStubCopy != nil {
		return crashActualLRPStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.crashActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeActualLRPDB) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) CrashActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) (*models.ActualLRP, *models.ActualLRP, bool, error)) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = stub
}

func (fake *FakeActualLRPDB) CrashActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	argsForCall := fake.crashActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeActualLRPDB) CrashActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 bool, result4 error) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeActualLRPDB) CrashActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 bool, result4 error) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = nil
	if fake.crashActualLRPReturnsOnCall == nil {
		fake.crashActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 bool
			result4 error
		})
	}
	fake.crashActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey) (*models.ActualLRP, error) {
	fake.createUnclaimedActualLRPMutex.Lock()
	ret, specificReturn := fake.createUnclaimedActualLRPReturnsOnCall[len(fake.createUnclaimedActualLRPArgsForCall)]
	fake.createUnclaimedActualLRPArgsForCall = append(fake.createUnclaimedActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("CreateUnclaimedActualLRP", []interface{}{arg1, arg2, arg3})
	createUnclaimedActualLRPStubCopy := fake.CreateUnclaimedActualLRPStub
	fake.createUnclaimedActualLRPMutex.Unlock()
	if createUnclaimedActualLRPStubCopy != nil {
		return createUnclaimedActualLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createUnclaimedActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPCallCount() int {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	return len(fake.createUnclaimedActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey) (*models.ActualLRP, error)) {
	fake.createUnclaimedActualLRPMutex.Lock()
	defer fake.createUnclaimedActualLRPMutex.Unlock()
	fake.CreateUnclaimedActualLRPStub = stub
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey) {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	argsForCall := fake.createUnclaimedActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPReturns(result1 *models.ActualLRP, result2 error) {
	fake.createUnclaimedActualLRPMutex.Lock()
	defer fake.createUnclaimedActualLRPMutex.Unlock()
	fake.CreateUnclaimedActualLRPStub = nil
	fake.createUnclaimedActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 error) {
	fake.createUnclaimedActualLRPMutex.Lock()
	defer fake.createUnclaimedActualLRPMutex.Unlock()
	fake.CreateUnclaimedActualLRPStub = nil
	if fake.createUnclaimedActualLRPReturnsOnCall == nil {
		fake.createUnclaimedActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 error
		})
	}
	fake.createUnclaimedActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) FailActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey, arg4 string) (*models.ActualLRP, *models.ActualLRP, error) {
	fake.failActualLRPMutex.Lock()
	ret, specificReturn := fake.failActualLRPReturnsOnCall[len(fake.failActualLRPArgsForCall)]
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("FailActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	failActualLRPStubCopy := fake.FailActualLRPStub
	fake.failActualLRPMutex.Unlock()
	if failActualLRPStubCopy != nil {
		return failActualLRPStubCopy(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.failActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeActualLRPDB) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) FailActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey, string) (*models.ActualLRP, *models.ActualLRP, error)) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = stub
}

func (fake *FakeActualLRPDB) FailActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	argsForCall := fake.failActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeActualLRPDB) FailActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) FailActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = nil
	if fake.failActualLRPReturnsOnCall == nil {
		fake.failActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.failActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) RemoveActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 string, arg4 int32, arg5 *models.ActualLRPInstanceKey) error {
	fake.removeActualLRPMutex.Lock()
	ret, specificReturn := fake.removeActualLRPReturnsOnCall[len(fake.removeActualLRPArgsForCall)]
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 string
		arg4 int32
		arg5 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("RemoveActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	removeActualLRPStubCopy := fake.RemoveActualLRPStub
	fake.removeActualLRPMutex.Unlock()
	if removeActualLRPStubCopy != nil {
		return removeActualLRPStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeActualLRPReturns
	return fakeReturns.result1
}

func (fake *FakeActualLRPDB) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) RemoveActualLRPCalls(stub func(context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = stub
}

func (fake *FakeActualLRPDB) RemoveActualLRPArgsForCall(i int) (context.Context, lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	argsForCall := fake.removeActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeActualLRPDB) RemoveActualLRPReturns(result1 error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPDB) RemoveActualLRPReturnsOnCall(i int, result1 error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = nil
	if fake.removeActualLRPReturnsOnCall == nil {
		fake.removeActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPDB) StartActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey, arg5 *models.ActualLRPNetInfo) (*models.ActualLRP, *models.ActualLRP, error) {
	fake.startActualLRPMutex.Lock()
	ret, specificReturn := fake.startActualLRPReturnsOnCall[len(fake.startActualLRPArgsForCall)]
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 *models.ActualLRPNetInfo
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("StartActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	startActualLRPStubCopy := fake.StartActualLRPStub
	fake.startActualLRPMutex.Unlock()
	if startActualLRPStubCopy != nil {
		return startActualLRPStubCopy(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.startActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeActualLRPDB) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) StartActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) (*models.ActualLRP, *models.ActualLRP, error)) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = stub
}

func (fake *FakeActualLRPDB) StartActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	argsForCall := fake.startActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeActualLRPDB) StartActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) StartActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = nil
	if fake.startActualLRPReturnsOnCall == nil {
		fake.startActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.startActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) UnclaimActualLRP(arg1 context.Context, arg2 lager.Logger, arg3 *models.ActualLRPKey) (*models.ActualLRP, *models.ActualLRP, error) {
	fake.unclaimActualLRPMutex.Lock()
	ret, specificReturn := fake.unclaimActualLRPReturnsOnCall[len(fake.unclaimActualLRPArgsForCall)]
	fake.unclaimActualLRPArgsForCall = append(fake.unclaimActualLRPArgsForCall, struct {
		arg1 context.Context
		arg2 lager.Logger
		arg3 *models.ActualLRPKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("UnclaimActualLRP", []interface{}{arg1, arg2, arg3})
	unclaimActualLRPStubCopy := fake.UnclaimActualLRPStub
	fake.unclaimActualLRPMutex.Unlock()
	if unclaimActualLRPStubCopy != nil {
		return unclaimActualLRPStubCopy(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.unclaimActualLRPReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeActualLRPDB) UnclaimActualLRPCallCount() int {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	return len(fake.unclaimActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) UnclaimActualLRPCalls(stub func(context.Context, lager.Logger, *models.ActualLRPKey) (*models.ActualLRP, *models.ActualLRP, error)) {
	fake.unclaimActualLRPMutex.Lock()
	defer fake.unclaimActualLRPMutex.Unlock()
	fake.UnclaimActualLRPStub = stub
}

func (fake *FakeActualLRPDB) UnclaimActualLRPArgsForCall(i int) (context.Context, lager.Logger, *models.ActualLRPKey) {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	argsForCall := fake.unclaimActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeActualLRPDB) UnclaimActualLRPReturns(result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.unclaimActualLRPMutex.Lock()
	defer fake.unclaimActualLRPMutex.Unlock()
	fake.UnclaimActualLRPStub = nil
	fake.unclaimActualLRPReturns = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) UnclaimActualLRPReturnsOnCall(i int, result1 *models.ActualLRP, result2 *models.ActualLRP, result3 error) {
	fake.unclaimActualLRPMutex.Lock()
	defer fake.unclaimActualLRPMutex.Unlock()
	fake.UnclaimActualLRPStub = nil
	if fake.unclaimActualLRPReturnsOnCall == nil {
		fake.unclaimActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRP
			result2 *models.ActualLRP
			result3 error
		})
	}
	fake.unclaimActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRP
		result2 *models.ActualLRP
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	fake.changeActualLRPPresenceMutex.RLock()
	defer fake.changeActualLRPPresenceMutex.RUnlock()
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	fake.countActualLRPsByStateMutex.RLock()
	defer fake.countActualLRPsByStateMutex.RUnlock()
	fake.countDesiredInstancesMutex.RLock()
	defer fake.countDesiredInstancesMutex.RUnlock()
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeActualLRPDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.ActualLRPDB = new(FakeActualLRPDB)
